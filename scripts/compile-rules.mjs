import { createHash } from "node:crypto"
import { promises as fs } from "node:fs"
import path from "node:path"

const ROOT = process.cwd()
const SOURCE_DIR = path.join(ROOT, "rules")
const CURSOR_DIR = path.join(ROOT, ".cursor", "rules")
const CLAUDE_PATH = path.join(ROOT, "CLAUDE.md")
const AGENTS_PATH = path.join(ROOT, "AGENTS.md")

const isIgnored = (fileName) => fileName === ".DS_Store"

const listFiles = async (dir) => {
  const entries = await fs.readdir(dir, { withFileTypes: true })
  const results = []

  for (const entry of entries) {
    if (isIgnored(entry.name)) {
      continue
    }

    const fullPath = path.join(dir, entry.name)

    if (entry.isDirectory()) {
      const nested = await listFiles(fullPath)
      results.push(...nested)
    } else if (entry.isFile()) {
      results.push(fullPath)
    }
  }

  return results.sort((a, b) => a.localeCompare(b))
}

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true })
}

const sha256 = (buffer) => createHash("sha256").update(buffer).digest("hex")

const generateBundle = async (sourceFiles) => {
  const mdcFiles = sourceFiles
    .filter((filePath) => filePath.endsWith(".mdc"))
    .sort((a, b) => a.localeCompare(b))

  const sections = []

  for (const absPath of mdcFiles) {
    const relativePath = path.relative(SOURCE_DIR, absPath).split(path.sep).join("/")
    const content = await fs.readFile(absPath, "utf8")

    sections.push(`## ${relativePath}\n\n\`\`\`mdc\n${content.trimEnd()}\n\`\`\``)
  }

  return sections.join("\n\n")
}

const renderClaude = (bundle) =>
  `# CLAUDE.md\n\nThis file is auto-generated by \`pnpm rules:compile\`.\nDo not edit manually. Edit files in \`/rules\` and recompile.\n\n## Project Rules\n\n${bundle}\n`

const renderAgents = (bundle) =>
  `# AGENTS.md\n\nThis file is auto-generated by \`pnpm rules:compile\`.\nDo not edit manually. Edit files in \`/rules\` and recompile.\n\n## Project Rules\n\n${bundle}\n`

const syncCursorRules = async (sourceFiles) => {
  await fs.rm(CURSOR_DIR, { recursive: true, force: true })
  await ensureDir(CURSOR_DIR)

  for (const sourcePath of sourceFiles) {
    const relativePath = path.relative(SOURCE_DIR, sourcePath)
    const targetPath = path.join(CURSOR_DIR, relativePath)
    await ensureDir(path.dirname(targetPath))
    await fs.copyFile(sourcePath, targetPath)
  }
}

const checkCursorRules = async (sourceFiles) => {
  const sourceMap = new Map()

  for (const sourcePath of sourceFiles) {
    const rel = path.relative(SOURCE_DIR, sourcePath).split(path.sep).join("/")
    const content = await fs.readFile(sourcePath)
    sourceMap.set(rel, sha256(content))
  }

  let cursorFiles = []
  try {
    cursorFiles = await listFiles(CURSOR_DIR)
  } catch {
    return ["Missing .cursor/rules directory"]
  }

  const cursorMap = new Map()
  for (const cursorPath of cursorFiles) {
    const rel = path.relative(CURSOR_DIR, cursorPath).split(path.sep).join("/")
    const content = await fs.readFile(cursorPath)
    cursorMap.set(rel, sha256(content))
  }

  const errors = []

  for (const [filePath, hash] of sourceMap.entries()) {
    if (!cursorMap.has(filePath)) {
      errors.push(`Missing generated file: .cursor/rules/${filePath}`)
      continue
    }

    if (cursorMap.get(filePath) !== hash) {
      errors.push(`Outdated generated file: .cursor/rules/${filePath}`)
    }
  }

  for (const filePath of cursorMap.keys()) {
    if (!sourceMap.has(filePath)) {
      errors.push(`Unexpected generated file: .cursor/rules/${filePath}`)
    }
  }

  return errors
}

const readIfExists = async (filePath) => {
  try {
    return await fs.readFile(filePath, "utf8")
  } catch {
    return null
  }
}

const main = async () => {
  const checkOnly = process.argv.includes("--check")

  let sourceFiles = []
  try {
    sourceFiles = await listFiles(SOURCE_DIR)
  } catch {
    console.error("Missing rules source directory: /rules")
    process.exit(1)
  }

  const bundle = await generateBundle(sourceFiles)
  const nextClaude = renderClaude(bundle)
  const nextAgents = renderAgents(bundle)

  if (checkOnly) {
    const errors = await checkCursorRules(sourceFiles)

    const currentClaude = await readIfExists(CLAUDE_PATH)
    const currentAgents = await readIfExists(AGENTS_PATH)

    if (currentClaude !== nextClaude) {
      errors.push("Outdated generated file: CLAUDE.md")
    }

    if (currentAgents !== nextAgents) {
      errors.push("Outdated generated file: AGENTS.md")
    }

    if (errors.length > 0) {
      console.error("Rules are not compiled or are out of date:\n")
      for (const error of errors) {
        console.error(`- ${error}`)
      }
      process.exit(1)
    }

    console.log("Rules are up to date.")
    return
  }

  await syncCursorRules(sourceFiles)
  await fs.writeFile(CLAUDE_PATH, nextClaude, "utf8")
  await fs.writeFile(AGENTS_PATH, nextAgents, "utf8")

  console.log("Compiled rules for Cursor, Claude, and Codex.")
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
