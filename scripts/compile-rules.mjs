import { createHash } from "node:crypto"
import { promises as fs } from "node:fs"
import path from "node:path"

const ROOT = process.cwd()
const SOURCE_DIR = path.join(ROOT, "rules")
const CURSOR_DIR = path.join(ROOT, ".cursor", "rules")
const CLAUDE_RULES_DIR = path.join(ROOT, ".claude", "rules")
const CLAUDE_PATH = path.join(ROOT, "CLAUDE.md")
const AGENTS_PATH = path.join(ROOT, "AGENTS.md")

const isIgnored = (fileName) => fileName === ".DS_Store"

const listFiles = async (dir) => {
  const entries = await fs.readdir(dir, { withFileTypes: true })
  const results = []

  for (const entry of entries) {
    if (isIgnored(entry.name)) {
      continue
    }

    const fullPath = path.join(dir, entry.name)

    if (entry.isDirectory()) {
      const nested = await listFiles(fullPath)
      results.push(...nested)
    } else if (entry.isFile()) {
      results.push(fullPath)
    }
  }

  return results.sort((a, b) => a.localeCompare(b))
}

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true })
}

const sha256 = (buffer) => createHash("sha256").update(buffer).digest("hex")

const normalizeRel = (baseDir, filePath) =>
  path.relative(baseDir, filePath).split(path.sep).join("/")

const parseMdc = (content) => {
  const trimmed = content.trimStart()
  if (!trimmed.startsWith("---")) {
    return { frontmatter: null, body: content.trimEnd() }
  }

  const lines = trimmed.split("\n")
  if (lines[0] !== "---") {
    return { frontmatter: null, body: content.trimEnd() }
  }

  let closingIndex = -1
  for (let i = 1; i < lines.length; i += 1) {
    if (lines[i] === "---") {
      closingIndex = i
      break
    }
  }

  if (closingIndex === -1) {
    return { frontmatter: null, body: content.trimEnd() }
  }

  const frontmatterLines = lines.slice(1, closingIndex)
  const body = lines
    .slice(closingIndex + 1)
    .join("\n")
    .trimStart()
    .trimEnd()
  const frontmatter = {}

  for (const line of frontmatterLines) {
    const idx = line.indexOf(":")
    if (idx === -1) continue
    const key = line.slice(0, idx).trim()
    const value = line.slice(idx + 1).trim()
    frontmatter[key] = value.replace(/^"(.*)"$/, "$1")
  }

  return { frontmatter, body }
}

const toClaudeRule = (content) => {
  const { frontmatter, body } = parseMdc(content)

  if (!frontmatter) {
    return content.trimEnd()
  }

  const globs = (frontmatter.globs ?? "")
    .split(",")
    .map((item) => item.trim())
    .filter(Boolean)
    .filter((item) => item !== "*")

  if (globs.length === 0) {
    return body
  }

  const pathLines = globs.map((glob) => `  - "${glob}"`).join("\n")
  return `---\npaths:\n${pathLines}\n---\n\n${body}`
}

const generateBundle = async (sourceFiles) => {
  const mdcFiles = sourceFiles
    .filter((filePath) => filePath.endsWith(".mdc"))
    .sort((a, b) => a.localeCompare(b))

  const sections = []

  for (const absPath of mdcFiles) {
    const relativePath = normalizeRel(SOURCE_DIR, absPath)
    const content = await fs.readFile(absPath, "utf8")

    sections.push(`## ${relativePath}\n\n\`\`\`mdc\n${content.trimEnd()}\n\`\`\``)
  }

  return sections.join("\n\n")
}

const renderClaude = (bundle) =>
  `# CLAUDE.md\n\nThis file is auto-generated by \`pnpm rules:compile\`.\nDo not edit manually. Edit files in \`/rules\` and recompile.\n\n## Project Rules\n\n${bundle}\n`

const renderAgents = (bundle) =>
  `# AGENTS.md\n\nThis file is auto-generated by \`pnpm rules:compile\`.\nDo not edit manually. Edit files in \`/rules\` and recompile.\n\n## Project Rules\n\n${bundle}\n`

const syncCursorRules = async (sourceFiles) => {
  await fs.rm(CURSOR_DIR, { recursive: true, force: true })
  await ensureDir(CURSOR_DIR)

  for (const sourcePath of sourceFiles) {
    const relativePath = path.relative(SOURCE_DIR, sourcePath)
    const targetPath = path.join(CURSOR_DIR, relativePath)
    await ensureDir(path.dirname(targetPath))
    await fs.copyFile(sourcePath, targetPath)
  }
}

const syncClaudeRules = async (sourceFiles) => {
  await fs.rm(CLAUDE_RULES_DIR, { recursive: true, force: true })
  await ensureDir(CLAUDE_RULES_DIR)

  const mdcFiles = sourceFiles
    .filter((sourcePath) => sourcePath.endsWith(".mdc"))
    .sort((a, b) => a.localeCompare(b))

  for (const sourcePath of mdcFiles) {
    const relativePath = normalizeRel(SOURCE_DIR, sourcePath).replace(/\.mdc$/, ".md")
    const targetPath = path.join(CLAUDE_RULES_DIR, relativePath)
    const sourceContent = await fs.readFile(sourcePath, "utf8")
    const claudeContent = `${toClaudeRule(sourceContent)}\n`

    await ensureDir(path.dirname(targetPath))
    await fs.writeFile(targetPath, claudeContent, "utf8")
  }
}

const checkCursorRules = async (sourceFiles) => {
  const sourceMap = new Map()

  for (const sourcePath of sourceFiles) {
    const rel = path.relative(SOURCE_DIR, sourcePath).split(path.sep).join("/")
    const content = await fs.readFile(sourcePath)
    sourceMap.set(rel, sha256(content))
  }

  let cursorFiles = []
  try {
    cursorFiles = await listFiles(CURSOR_DIR)
  } catch {
    return ["Missing .cursor/rules directory"]
  }

  const cursorMap = new Map()
  for (const cursorPath of cursorFiles) {
    const rel = path.relative(CURSOR_DIR, cursorPath).split(path.sep).join("/")
    const content = await fs.readFile(cursorPath)
    cursorMap.set(rel, sha256(content))
  }

  const errors = []

  for (const [filePath, hash] of sourceMap.entries()) {
    if (!cursorMap.has(filePath)) {
      errors.push(`Missing generated file: .cursor/rules/${filePath}`)
      continue
    }

    if (cursorMap.get(filePath) !== hash) {
      errors.push(`Outdated generated file: .cursor/rules/${filePath}`)
    }
  }

  for (const filePath of cursorMap.keys()) {
    if (!sourceMap.has(filePath)) {
      errors.push(`Unexpected generated file: .cursor/rules/${filePath}`)
    }
  }

  return errors
}

const checkClaudeRules = async (sourceFiles) => {
  const expectedMap = new Map()
  const mdcFiles = sourceFiles
    .filter((sourcePath) => sourcePath.endsWith(".mdc"))
    .sort((a, b) => a.localeCompare(b))

  for (const sourcePath of mdcFiles) {
    const rel = normalizeRel(SOURCE_DIR, sourcePath).replace(/\.mdc$/, ".md")
    const sourceContent = await fs.readFile(sourcePath, "utf8")
    expectedMap.set(rel, sha256(Buffer.from(`${toClaudeRule(sourceContent)}\n`)))
  }

  let actualFiles = []
  try {
    actualFiles = await listFiles(CLAUDE_RULES_DIR)
  } catch {
    return ["Missing generated directory: .claude/rules"]
  }

  const actualMap = new Map()
  for (const actualPath of actualFiles) {
    const rel = normalizeRel(CLAUDE_RULES_DIR, actualPath)
    const content = await fs.readFile(actualPath)
    actualMap.set(rel, sha256(content))
  }

  const errors = []

  for (const [filePath, hash] of expectedMap.entries()) {
    if (!actualMap.has(filePath)) {
      errors.push(`Missing generated file: .claude/rules/${filePath}`)
      continue
    }

    if (actualMap.get(filePath) !== hash) {
      errors.push(`Outdated generated file: .claude/rules/${filePath}`)
    }
  }

  for (const filePath of actualMap.keys()) {
    if (!expectedMap.has(filePath)) {
      errors.push(`Unexpected generated file: .claude/rules/${filePath}`)
    }
  }

  return errors
}

const readIfExists = async (filePath) => {
  try {
    return await fs.readFile(filePath, "utf8")
  } catch {
    return null
  }
}

const main = async () => {
  const checkOnly = process.argv.includes("--check")

  let sourceFiles = []
  try {
    sourceFiles = await listFiles(SOURCE_DIR)
  } catch {
    console.error("Missing rules source directory: /rules")
    process.exit(1)
  }

  const bundle = await generateBundle(sourceFiles)
  const nextClaude = renderClaude(bundle)
  const nextAgents = renderAgents(bundle)

  if (checkOnly) {
    const errors = [
      ...(await checkCursorRules(sourceFiles)),
      ...(await checkClaudeRules(sourceFiles)),
    ]

    const currentClaude = await readIfExists(CLAUDE_PATH)
    const currentAgents = await readIfExists(AGENTS_PATH)

    if (currentClaude !== nextClaude) {
      errors.push("Outdated generated file: CLAUDE.md")
    }

    if (currentAgents !== nextAgents) {
      errors.push("Outdated generated file: AGENTS.md")
    }

    if (errors.length > 0) {
      console.error("Rules are not compiled or are out of date:\n")
      for (const error of errors) {
        console.error(`- ${error}`)
      }
      process.exit(1)
    }

    console.log("Rules are up to date.")
    return
  }

  await syncCursorRules(sourceFiles)
  await syncClaudeRules(sourceFiles)
  await fs.writeFile(CLAUDE_PATH, nextClaude, "utf8")
  await fs.writeFile(AGENTS_PATH, nextAgents, "utf8")

  console.log("Compiled rules for Cursor, Claude, and Codex.")
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
