# CLAUDE.md

This file is auto-generated by `pnpm rules:compile`.
Do not edit manually. Edit files in `/rules` and recompile.

## Project Rules

## api.mdc

```mdc
---
description: "Umbrella: API layer — route handlers, validation, response shapes, services"
globs: "app/api/**/*,services/**/*"
alwaysApply: false
---

# API Rules (umbrella)

Use **@api** when working on route handlers, validation, or backend boundaries.

This rule references:

- **Route handlers**: `.cursor/rules/nextjs/route-handlers.mdc` — thin handlers, no logic in route
- **Response shapes**: `.cursor/rules/nextjs/api-response-shapes.mdc` — `{ data }` / `{ error: { code, message } }`, status codes
- **Server actions**: `.cursor/rules/nextjs/server-actions.mdc` — input validation and typed action results
- **Validation**: `.cursor/rules/api/validation.mdc` — validate at boundary, guard/coercion helpers in `utils/validation/`
- **Services vs utils**: `.cursor/rules/backend/services-and-utils.mdc` — utils = pure; services = IO/DB/auth

## Short summary

- Handler: parse/validate input → call one service → return explicit response.
- Success: `Response.json({ data })`; error: `Response.json({ error: { code, message } }, { status })`.
- No business logic or DB access in the handler.
```

## api/validation.mdc

```mdc
---
description: Validation strategy (no new dependencies)
globs: "app/api/**/route.ts,services/**/*.ts,utils/**/*.ts"
alwaysApply: true
---

# Validation Strategy (no new dependencies)

## Goal

Validate inputs consistently without adding validation libraries.

## Where validation lives

- **Route handlers**: validate request shape at the boundary.
- **Services**: validate invariants when enforcing domain policies.
- **Utils**: keep small coercion/guard helpers under `utils/validation/`.

## Patterns

- Prefer `unknown` inputs at boundaries + explicit narrowing.
- Use tiny guard/coercion helpers instead of casting.
- If the project already uses Zod, prefer Zod schemas at boundaries; do not add Zod only for trivial validation.

## Recommended helpers (examples)

- `utils/validation/isRecord.ts` -> `value is Record<string, unknown>`
- `utils/validation/coerceFirstString.ts` -> `unknown -> string | null`
- `utils/validation/coerceNumber.ts` -> `unknown -> number | null`

## Rules

- No inline types or helpers inside route handlers.
- If validation logic grows, split into dedicated helpers (one function per file).
```

## backend/services-and-utils.mdc

```mdc
---
description: Contracts and naming for services/ vs utils/ (agent-optimized)
globs: "*.ts,*.tsx,*.js,*.mjs,*.cjs"
alwaysApply: false
---

# services/ vs utils/ (contracts)

## utils/ (pure logic)

Use `utils/<area>/xxx.ts` when code is:

- Pure (no IO, no DB, no network, no cookies/headers)
- Deterministic (same input -> same output)
- Easy to unit test

**Naming:** verb-noun, focused

- `utils/ids/formatDisplayId.ts`
- `utils/dates/parseIsoDate.ts`

**API:** single exported function; throw only for programmer errors; return explicit values.

## services/ (external boundary)

Use `services/<area>/xxx.ts` when code:

- Talks to network/DB/auth/storage
- Reads cookies/headers or environment
- Enforces domain policies at a boundary

**Naming:** verb-noun, intent-first

- `services/resources/createResource.ts`
- `services/auth/getSession.ts`

**API guidance:**

- Return domain data or typed result objects; avoid returning framework primitives from deep services.
- Prefer explicit error shapes over throwing for expected failures.

## app route handlers

- Must be **thin**: validate input, call a service, return a response.
- No business logic; no data mapping beyond request/response translation.
```

## backend/supabase-services.mdc

```mdc
---
description: Supabase services usage (only if Supabase is added)
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Supabase Services Usage

## Rule

This rule only applies if/when this repository adds Supabase.

- Route handlers, hooks, utils, and components must NOT call Supabase directly.
- Centralize reads/writes in `services/supabase/` modules.
- Never import `@supabase/supabase-js` outside the Supabase client setup or `services/supabase/*`.
```

## backend/supabase.mdc

```mdc
---
description: Supabase access rule (only if Supabase is added)
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Supabase Access Rule

## Scope

This rule only applies if/when this repository adds Supabase.

## Guideline

- Isolate Supabase access in `services/supabase/*` wrappers.
- Do not call Supabase client methods directly from components, hooks, utils, or route handlers.
- Keep wrappers small, focused, and typed.
```

## bash.mdc

```mdc
---
description: "Umbrella: Bash/Shell standards and refactor workflow"
globs: "*.sh"
alwaysApply: false
---

# Bash Rules (umbrella)

Use **@bash** when working on Bash or shell scripts.

This rule references:

- **Bash standards**: `.cursor/rules/bash/bash.mdc` — language, structure, functions, IO, layout, validation
- **Bash refactor**: `.cursor/rules/bash/refactor.mdc` — @file refactor workflow for .sh files

## Short summary

- One responsibility per script; entry scripts thin (parse + call helpers); helpers in `scripts/bash/utils/` or area subfolders.
- Validate with `bash -n` and `shellcheck` where possible.
```

## bash/bash.mdc

```mdc
---
description: Bash/Shell script standards for server and automation
globs: "*.sh"
alwaysApply: false
---

# Bash/Shell Standards

## Language & Style

- Use `#!/usr/bin/env -S bash` or `#!/bin/bash` consistently at the top of executables.
- Enable strict mode in non-trivial scripts: `set -euo pipefail`; use `IFS=$'\n\t'` when safe.
- Use lowercase snake_case for function names; UPPER_CASE for constants and env vars.
- Prefer long flags (`--help`) over short ones when available.
- Comments focused on "why" more than "what".

## Modules & Structure

- Keep files **single-responsibility and small**; extract helpers proactively.
- **One responsibility per script file**: CLI entry scripts parse args/env and call helpers; helpers live in `utils/` or area subfolders.
- Do not rename entry scripts invoked from server/cron; move logic into `scripts/<area>/utils/*.sh` and have the entry script `source` and call one entry function.
- Use `source "$(dirname "$0")/relative/path/to/helper.sh"` so paths work regardless of CWD.

## Functions

- Prefer small, focused functions; avoid multiple unrelated functions in the same file.
- Reuse existing helpers; extend with parameters rather than duplicating.
- Validate input parameters early; exit with a clear message on invalid input.

## IO & Errors

- Use explicit non-zero exit codes on failure (`exit 1`, `exit 2`, etc. with meaning).
- Print machine-friendly logs by default; avoid excessive noise in cron jobs.
- Send errors to stderr (`echo "message" >&2`). Never echo secrets to output.

## Layout (suggested)

- Top-level executable scripts (names unchanged for compatibility).
- `scripts/bash/utils/*.sh` — shared helpers (logging, color output, common helpers).
- `scripts/bash/<area>/*.sh` — area-specific helpers when needed.

## Validation

- Prefer running `shellcheck` on new or modified scripts where possible.
- Keep POSIX vs bash-specific constructs consistent with the shebang.

## Naming (DevOps / automation)

- Use `snake_case` for variables and functions; use `snake_case` for file and directory names.
- UPPER_CASE for environment variables.
- Avoid hard-coded values; use environment variables or config files.
- Principle of least privilege for access and permissions.
- Use `trap` for error handling and cleaning up temporary files.
- Redirect output to log files where appropriate; separate stdout and stderr.
```

## bash/refactor.mdc

```mdc
---
description: One-shot refactor of a Bash file (@file, .sh)
globs: "*.sh"
alwaysApply: false
---

# @file Bash Refactor Workflow

Use this rule by referencing **@file** on a Bash script. Apply the following steps to the selected file.

## Goals

- Make the script small, readable, and single-responsibility.
- Keep the **entry script filename unchanged** so external/server calls keep working.
- Move reusable logic into `utils/` (and area subfolders) as separate `.sh` files.
- Prefer one logical entry function per file; extract additional helpers to dedicated files.
- After edits, validate with `bash -n` and, when possible, `shellcheck`.

## Algorithm

1. **Scan** — Identify responsibilities: CLI entry (args/env + usage), I/O boundaries (fs, network, DB), pure helpers.
2. **Decide** — Keep CLI parsing + top-level orchestration in the entry script; move shared helpers to `scripts/bash/utils/*.sh` or `scripts/bash/<area>/utils/*.sh`; keep files small.
3. **Wire** — Add `source "$(dirname "$0")/relative/path/to/helper.sh"` at the top; replace inlined functions with calls to imported helpers.
4. **Safety** — Preserve script interface (arguments, env vars, exit codes). Do not change entry script filename or shebang.
5. **Validate** — Run `bash -n <script>`; prefer existing integration flows (cron/CI) where feasible.

## Acceptance Criteria

- File responsibilities are clear and minimal.
- Entry scripts are thin: mostly argument parsing + one main function call.
- Shared helpers live in `scripts/bash/utils/` (and area subfolders when needed).
- No changes to entry script filenames; paths compatible with existing server calls.
- No syntax errors (`bash -n` clean) and no new `shellcheck` warnings where used.
```

## core.mdc

```mdc
---
description: "Umbrella: core project rules (file discipline, boundaries, naming, anti-patterns)"
globs: "*.ts,*.tsx,*.js,*.mjs,*.cjs"
alwaysApply: false
---

# Core Rules (umbrella)

Use **@core** when you need the full set of core project rules in one go.

This rule references the following; for full detail open each:

- **Project & quality**: `.cursor/rules/core/project.mdc` — one-thing-per-file, check script
- **General**: `.cursor/rules/core/general.mdc` — agent defaults, code style, repo hygiene
- **Text hygiene**: `.cursor/rules/core/text-hygiene.mdc` — ASCII punctuation and no invisible chars in docs/config
- **JavaScript umbrella** (optional): `.cursor/rules/javascript.mdc` — cross-runtime JS/TS domain rules
- **Boundaries**: `.cursor/rules/core/boundaries.mdc` — where to put routes, components, hooks, utils, services, types
- **Naming & layout**: `.cursor/rules/core/naming-and-layout.mdc` — folder layout, file naming, exports
- **Anti-patterns**: `.cursor/rules/core/anti-patterns.mdc` — what to avoid (barrels, inline types, fat handlers)
- **Security baseline**: `.cursor/rules/core/security-baseline.mdc` — XSS/secrets/least-privilege defaults

## Short summary

- Many small files; one exported symbol per file; no inline types; no helpers inside components/hooks.
- Route handlers thin: validate → call service → return response.
- Run the project check script after meaningful changes.
- For non-JS/TS stacks, use stack umbrellas directly (`@php`, `@rust`, `@bash`).
```

## core/anti-patterns.mdc

```mdc
---
description: Anti-patterns to avoid (agent-optimized)
globs: "*"
alwaysApply: true
---

# Anti-Patterns (avoid)

These patterns destroy agent context quality and make refactors risky.

## File Structure

- **Multiple exports per file** (any combination of component/hook/function/type).
- **Barrel/index files** (`index.ts`) that hide dependencies.
- **Growing "misc" modules** (`helpers.ts`, `utils.ts`, `types.ts`, `constants.ts`).
- **God functions** that fetch/read/parse/transform/branch in one place instead of being split into single-purpose helpers.
- **TODO/placeholders** in delivered code.

## Types

- **Inline types** in components/hooks/utils/services/route handlers.
- **One huge type file** that becomes a dumping ground.

## React

- **Fetching/DB calls inside components**.
- **Helpers inside components/hooks** (formatting, parsing, mapping) instead of `utils/`.
- Marking a whole subtree `'use client'` just to use one hook; prefer smaller client islands.
- **Prop drilling** when a store would be cleaner for shared state.
- **useState for modal visibility** when multiple components need to toggle it; prefer a store.

## App Router / API

- **Fat route handlers** that contain business logic.
- Returning unvalidated input; always validate and return explicit responses.

## Dependencies

- Adding a new dependency without first checking whether the repo already has one that solves the same problem.
- Rebuilding complex systems in-house when a mature library is the better engineering choice.
```

## core/boundaries.mdc

```mdc
---
description: Boundaries & placement rules (agent-optimized)
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Boundaries & Placement (agent-optimized)

## Goal

Make it obvious where new code belongs so agents can create **many small files** without guessing.

## Decision Tree (Next.js App Router layout)

If you are writing...

- **A route or page** -> `app/**` (route components, layouts, route handlers)
- **Reusable UI** -> `components/<area>/...`
- **State/effects + orchestration logic** -> `hooks/<area>/useXxx.ts`
- **Pure logic** (no React, no IO) -> `utils/<area>/xxx.ts`
- **External boundary** (network/DB/auth/storage) -> `services/<area>/xxx.ts`
- **A shared shape** -> `types/<area>/Xxx.ts`

## Hard Rules

- **One exported symbol per file** (component / hook / function / type).
- **No inline types** outside `types/`.
- **No helpers inside components/hooks**; helpers go to `utils/`.
- **Route handlers must be thin**: validate input, call a `services/` function, return a response.

## References

- Next.js: `.cursor/rules/nextjs/nextjs.mdc`
- Route handlers: `.cursor/rules/nextjs/route-handlers.mdc`
- API response shapes: `.cursor/rules/nextjs/api-response-shapes.mdc`
- Validation: `.cursor/rules/api/validation.mdc`
- Naming/layout: `.cursor/rules/core/naming-and-layout.mdc`
- utils vs services: `.cursor/rules/backend/services-and-utils.mdc`
- Anti-patterns: `.cursor/rules/core/anti-patterns.mdc`
```

## core/code-quality-guidelines.mdc

```mdc
---
description: Single source of truth for code quality (apply when creating and when refactoring)
globs: "*.ts,*.tsx"
alwaysApply: true
---

# Code Quality Guidelines

**Apply these guidelines when creating new code and when refactoring.** They are the single source of truth; other rules (e.g. @refactor, post-refactor checks) reference this file.

## File size

- **Target**: 10–50 lines per file.
- **Max**: ~100 lines; beyond that, split.

## Hard constraints

- Exactly one exported symbol per file.
- No inline `interface`/`type` in non-type files; put types in `types/<area>/` (one type per file).
- No helper functions inside components/hooks; extract to `utils/<area>/`.
- No index/barrel files; import from concrete modules.
- **Single-purpose functions only**: each function does one task. If a function contains multiple steps (fetch/read/parse/transform/branching), split into smaller functions and orchestrate them from a parent function.

## Framework-specific exceptions

Any framework-specific exceptions to "one export per file" live in the framework rule files (e.g. Next.js).

## Constants and large data

- Do not keep large literal collections (arrays/maps of many entries) inside logic files.
- Extract keyword lists, lookup maps, and config tables to dedicated constant files (e.g. `utils/<area>/constants/xxxConstants.ts`); logic files import them.

## When to split (fast heuristics)

Split immediately if any is true:

- More than one exported symbol.
- More than one responsibility (UI + state + helpers).
- Any helper function inside a component/hook.
- Inline `type`/`interface` outside `types/`.
- File > ~80 lines and still growing.

## Extraction decision tree

- File > ~80 lines → must extract (multiple functions → one per file; inline types → `types/<area>/`; complex logic → hook or util; repeated JSX → child components).
- Large constant collections → dedicated files under `utils/<area>/constants/` or similar.

## Decision rules (creating and refactoring)

- Apply SOLID principles: single responsibility per file; depend on abstractions where it helps.
- If a file has multiple responsibilities, split immediately.
- If a hook/component contains helpers, extract them to `utils/`.
- If a file declares types inline, move them to `types/<area>/`.
- Limit logic in TSX to presentational concerns; move complex logic to hooks or `utils/`.
- Pass full props into components; avoid computing derived data during prop passing; keep logic inside the component or its hooks.
- If a function reads like a checklist of steps, split it into small single-purpose functions and keep a thin orchestrator.

## Checklist (after creating or refactoring)

- [ ] All type errors resolved.
- [ ] All lint errors resolved.
- [ ] No unused imports.
- [ ] No circular dependencies.
- [ ] File size 10–50 lines (max ~100).
- [ ] One function/type/hook per file.
- [ ] Types in `types/<area>/`; no index/barrel files.

## Common issues and fixes

| Issue               | Fix                                        |
| ------------------- | ------------------------------------------ |
| Type error: `any`   | Use `unknown` and narrow with type guards. |
| Unused import       | Remove or use the import.                  |
| Missing return type | Add explicit return type.                  |
| Circular dependency | Move shared types to `types/`.             |
| File too large      | Split into smaller focused files.          |
```

## core/general.mdc

```mdc
---
description: General Engineering Guidelines (agent-optimized)
globs: "*"
alwaysApply: true
---

# General Engineering Guidelines

## Core Goal

Optimize for agent context by keeping **many small, focused files** and explicit boundaries.

## Scope Priority

- Primary by default: TypeScript, React, Next.js App Router, Tailwind.
- Secondary only when relevant in the repo: Zod, React Hook Form, Zustand, TanStack Query, `nuqs`, `next-safe-action`, Supabase, GraphQL tooling, Vercel AI SDK.
- Out of scope unless explicitly requested: React Native/Expo, Vue/Nuxt/Gatsby/SvelteKit, NestJS, Chrome Extensions, Pixi.js, Prisma.
- For other languages, use their umbrellas:
  - PHP: `@php`
  - Rust/Tauri: `@rust`
  - Go: `@go`
  - Monorepo/Turbo: `@monorepo`
  - Bash/Shell: `@bash`

## Agent Defaults

- Prefer small, safe changes over sweeping refactors unless requested.
- When requirements are ambiguous, ask a clarifying question before coding.
- Dependencies policy:
- First, check if an existing dependency in the repo already solves the problem (UI, icons, dates, validation, data access, etc.).
- If existing dependencies are insufficient, research and suggest the best-fit library with brief tradeoffs.
- Prefer mature libraries over building complex systems in-house (dates, advanced UI, rich text, DB/ORM, complex state/query layers).
- Keep changes reversible; avoid touching unrelated files.
- Use subagents to process multiple files in parallel when the task involves several independent edits.
- Plan before executing: create a short plan before modifying code; ask if scope is unclear.
- After meaningful changes: briefly reflect on maintainability and scalability; suggest improvements if needed.

## Code Style

- English-only code, comments, and identifiers.
- Prefer SOLID and KISS where applicable.
- Prefer pure functions and hooks; avoid unnecessary classes.
- Avoid deep nesting; extract early.
- Prefer guard clauses and early returns to reduce nesting.
- Avoid magic numbers; name them as constants.

## Priorities

- Correctness > clarity > maintainability > performance.

## Repo Hygiene

- No index/barrel files.
- One responsibility per file.
- Keep route handlers thin; move logic to `services/`.

## Network / API

- Implement proper error handling for network requests and responses; surface user-friendly errors when possible.
- Consider API versioning and CORS when designing or integrating with backends.
- For external backends: consider retries for transient failures and appropriate serialization for complex payloads.

## Quality Gate

- Always run the project's check script after meaningful changes (e.g. `pnpm run check`, `npm run check`).
```

## core/naming-and-layout.mdc

```mdc
---
description: Naming & layout conventions (agent-optimized)
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Naming & Layout Conventions

## Folder layout (Next.js App Router)

- `app/`: routing, layouts, route handlers
- `components/<area>/...`: reusable UI
- `hooks/<area>/useXxx.ts`: one hook per file
- `utils/<area>/xxx.ts`: one pure helper function per file (single-purpose)
- `services/<area>/xxx.ts`: one boundary function per file (single-purpose; network/DB/integrations)
- `types/<area>/Xxx.ts`: one type/interface per file
- `stores/<storeName>.ts`: Zustand (or similar) stores, when used

## File naming

- Directories: kebab-case.
- Components: PascalCase filenames, folder-namespaced when complex:
  - `components/orders/OrderCard/OrderCard.tsx`
  - `components/orders/OrderCard/Header.tsx`
- Hooks: `useXxx.ts`
- Utils/services: verb-noun, lower camel or lower kebab; pick one and stay consistent within a folder.
- Types: PascalCase, match the exported symbol name.

## Identifier naming

- Framework-agnostic naming rules stay here.
- React-specific handler/boolean/hook naming lives in `.cursor/rules/react/naming.mdc`.

## Exports

- Next.js route components (`app/**/page.tsx`, `layout.tsx`): **default export** (required by conventions).
- Reusable components/hooks/utils/services/types: **single export per file**.

## Imports

- No barrel/index files.
- Prefer relative imports within a domain folder; use aliases only when they reduce churn.

## Alternative: Frontend/backend split

When the repo has a separate frontend app (e.g. Vite) and backend:

- `frontend/src/components/` for UI; `frontend/src/hooks/`, `frontend/src/utils/`, `frontend/src/types/` for the rest.
- `backend/` (or equivalent) for server-only code.
- Same one-export-per-file and boundaries apply within each tree.
```

## core/project.mdc

```mdc
---
description: Project guidelines (strict one-thing-per-file, many small files)
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Project Guidelines

## Core Goal

Many small, focused files for maximum agent context efficiency.

## Strict File Discipline

- One exported component per `.tsx`.
- One exported hook per `hooks/**/useXxx.ts`.
- One exported function per `utils/**` and `services/**`.
- One exported type per `types/**`.
- No inline types outside `types/`.
- No helpers inside components/hooks.
- No index/barrel files.
- **Single-purpose functions only**: if a function does multiple tasks, split it and keep a thin orchestrator function.

## App Router Defaults (Next.js)

- Server Components by default.
- Add `'use client'` only when needed.
- Thin route handlers: `app/api/**/route.ts` -> call `services/`.
- Next.js special-file exceptions live in the Next.js rules.

## Quality Gate

- Run the project's check script after meaningful changes (e.g. `pnpm run check`, `npm run check`).

## References

- **When creating code**: follow [code-quality-guidelines.mdc](.cursor/rules/core/code-quality-guidelines.mdc) (file size 10–50, one per file, types in `types/`, etc.).
- Naming/layout: `.cursor/rules/core/naming-and-layout.mdc`
- Boundaries: `.cursor/rules/core/boundaries.mdc`
```

## core/security-baseline.mdc

```mdc
---
description: Security baseline for web features (XSS, secrets, least privilege)
globs: "*.ts,*.tsx,app/**/*,services/**/*"
alwaysApply: true
---

# Security Baseline

## Input and output safety

- Treat external input as untrusted; validate and narrow at boundaries.
- Do not render untrusted HTML directly.

## XSS protections

- Avoid `dangerouslySetInnerHTML` unless explicitly required.
- If raw HTML must be rendered, sanitize first with a reviewed sanitizer.

## Secrets and auth

- Never expose secrets to client bundles.
- Keep sensitive checks server-side even when client guards exist.
- Prefer least-privilege access patterns for roles/permissions.

## Logging

- Log actionable context, never secrets or personal tokens.
```

## core/text-hygiene.mdc

```mdc
---
description: Text hygiene for docs/config (ASCII punctuation)
globs: "*.md,*.mdc,.github/**/*"
alwaysApply: true
---

# Text Hygiene (ASCII)

## Goal

Keep docs/config text easy to diff and safe for tooling.

## Rules

- Prefer ASCII punctuation in edited/new text.
- Use straight quotes (`'` and `"`) instead of smart quotes.
- Use ASCII hyphen (`-`) instead of long dashes.
- Avoid invisible/problematic characters (NBSP, zero-width chars).
- Keep edits minimal; do not reformat unrelated content.

## Output discipline

- If non-ASCII text hygiene issues are found, call them out explicitly.
- Preserve meaning while replacing problematic characters.
```

## deploy.mdc

```mdc
---
description: "Umbrella: Deploy (K8s Helm, agent guidelines)"
globs: "*.sh,lib/**/*,*.yaml,.env*,deploy.sh"
alwaysApply: false
---

# Deploy Rules (umbrella)

Use **@deploy** when working on deployment scripts, K8s/Helm, or agent-driven deploy flows.

This rule references:

- **Sonnet/agent**: `.cursor/rules/deploy/sonnet.mdc` — codebase search first, list rules, output discipline
- **GitHub security**: `.cursor/rules/deploy/github-security.mdc` — secrets handling and workflow hardening

## Short summary

- Agent: search codebase first; check existing files before creating; list rules when helpful.
```

## deploy/github-security.mdc

```mdc
---
description: GitHub secret-handling and workflow hardening
globs: ".github/workflows/**/*,.env*,*.env"
alwaysApply: false
---

# GitHub Security and Secrets

## Non-negotiable

- Never hardcode secrets in code, docs, workflows, or examples.
- Never commit real `.env` files; keep placeholders in `.env.example`.
- Assume leaked credentials are compromised and must be rotated.

## CI/workflow rules

- Use least-privilege workflow `permissions:` and elevate only when needed.
- Prefer `GITHUB_TOKEN` when sufficient; avoid long-lived PATs.
- Treat forked PR input as untrusted; avoid unsafe interpolation in scripts.
- Pin third-party GitHub Actions to immutable versions (prefer full SHA).
- Avoid printing secrets in logs; mask sensitive runtime values before output.

## Incident baseline

1. Rotate/revoke exposed credentials first.
2. Remove/replace usage in code/config and redeploy.
3. Add prevention (ignore rules + secret scanning in dev/CI).
```

## deploy/sonnet.mdc

```mdc
---
description: Agent guidelines for Sonnet + Cursor (codebase search, rules, output)
globs: "*"
alwaysApply: false
---

# Agent Guidelines (Sonnet / Cursor)

## Required

1. Use **codebase_search** with `target_directories="."` first to find existing core files.
2. Check existing system files and their purposes before creating new ones with similar functionality.
3. List the Cursor rules you are using when asked or when it helps reproducibility.

## Optional (when the prompt specifies)

- Obey specified behaviors, languages, or output formats without deviation.
- Do not include explanations, reasoning, or filler unless explicitly requested.
- Address multiple steps in the specified order; use the exact format or sequence requested.
- Respect all constraints (language, performance, style); do not ignore requirements.
- Produce only output relevant to the request; avoid adding unrequested features or detail.
- Deliver minimal yet complete responses; avoid unnecessary verbosity.
- Follow requested output format (code block, bullets, JSON) exactly.
- If the prompt includes a pre-seeded structure (e.g. started code block), continue within that structure.
- If ambiguous and allowed, ask clarifying questions; otherwise state briefly that more information is needed.
- Follow best practices for clarity, maintainability, and efficiency for the given language or framework.
- Do not generate or include private data (API keys, secrets) unless explicitly provided; refuse or offer a safe alternative when appropriate.
```

## frontend.mdc

```mdc
---
description: "Umbrella: Next.js + React + styling (pages, components, hooks, Tailwind)"
globs: "app/**/*,components/**/*,hooks/**/*,*.tsx"
alwaysApply: false
---

# Frontend Rules (umbrella)

Use **@frontend** when working on UI, pages, components, or styling.

This rule references:

- **Next.js umbrella**: `.cursor/rules/nextjs.mdc` — App Router architecture bundle
- **React umbrella**: `.cursor/rules/react.mdc` — architecture, hooks, state, a11y, forms, performance
- **JavaScript umbrella** (optional): `.cursor/rules/javascript.mdc` — extensions, QA, RN/Expo, Shopify JS, cross-runtime rules
- **Next.js**: `.cursor/rules/nextjs/nextjs.mdc` — Server/Client components, special-file exports
- **Route handlers**: `.cursor/rules/nextjs/route-handlers.mdc` — thin API handlers
- **Server actions**: `.cursor/rules/nextjs/server-actions.mdc` — validation, typed result shapes, expected failures
- **Data fetching**: `.cursor/rules/nextjs/data-fetching.mdc` — RSC-first fetch and waterfall prevention
- **Forms/actions**: `.cursor/rules/nextjs/forms-and-actions.mdc` — form + action integration
- **Rendering/performance**: `.cursor/rules/nextjs/rendering-performance.mdc` — dynamic imports, image/script strategy
- **Error/observability**: `.cursor/rules/nextjs/error-observability.mdc` — boundaries and logging context
- **API responses**: `.cursor/rules/nextjs/api-response-shapes.mdc` — JSON shapes, status codes
- **Tailwind umbrella**: `.cursor/rules/tailwind.mdc` — Tailwind v4 standards split by concept
- **Bootstrap** (optional): `.cursor/rules/styling/bootstrap.mdc` — responsive grid/components/utilities with accessibility
- **HTMX** (optional): `.cursor/rules/javascript/htmx.mdc` — server-driven HTML fragments and declarative interactions
- **Vite runtime** (when using Vite): `.cursor/rules/vite/runtime-safety.mdc` — no Node globals in browser bundles; use `import.meta.env`
- **Next.js + Supabase** (optional): `.cursor/rules/integrations/nextjs-supabase.mdc` — auth/RLS and boundary-safe data access
- **Stripe subscriptions** (optional): `.cursor/rules/integrations/stripe-subscriptions.mdc` — webhook safety and subscription sync

## Short summary

- Server Components by default; `'use client'` only when needed.
- One component/hook per file; types in `types/`; helpers in `utils/`.
- Prefer Tailwind in `className`; avoid large custom CSS.
```

## go.mdc

```mdc
---
description: "Umbrella: Go backend and microservices standards"
globs: "*.go,go.mod,go.sum"
alwaysApply: false
---

# Go Rules (umbrella)

Use **@go** when working on Go codebases.

This rule references:

- **Go microservices**: `.cursor/rules/go/microservices.mdc` - clean architecture, interfaces, observability, resilience, testing

## Short summary

- Keep handlers thin and domain logic isolated.
- Depend on interfaces, use explicit DI, avoid global mutable state.
- Enforce context propagation, explicit error handling, and observability.
```

## go/microservices.mdc

```mdc
---
description: Go microservices standards (clean architecture, resilience, observability)
globs: "*.go,go.mod,go.sum"
alwaysApply: true
---

# Go Microservices Standards

## Architecture

- Prefer clean architecture boundaries: transport -> use case -> repository -> domain.
- Keep framework details at the edges; keep domain logic framework-agnostic.
- Program to interfaces for dependencies and external boundaries.
- Prefer small, purpose-specific interfaces and explicit constructor injection.

## Code quality

- Keep functions short and single-purpose.
- Handle errors explicitly and wrap with context (`fmt.Errorf("...: %w", err)`).
- Avoid global mutable state; use dependency injection and config structs.
- Prefer composition over inheritance-style abstractions.

## Concurrency and context

- Propagate `context.Context` through request and downstream calls.
- Honor cancellation/timeouts on I/O boundaries.
- Use goroutines safely; protect shared state with channels or sync primitives.
- Ensure resources are closed deterministically (`defer`).

## Resilience and security

- Validate/sanitize external input at boundaries.
- Use timeouts, retries, and bounded backoff for external calls where safe.
- Add rate limiting/circuit breaking on abuse-prone or fragile boundaries.
- Keep authn/authz explicit and least-privilege by default.

## Observability

- Add structured logs with request/trace correlation ids.
- Instrument critical paths (HTTP/gRPC, DB, external APIs) with metrics/traces.
- Track core signals: latency, throughput, error rate, saturation.

## Testing and tooling

- Use table-driven unit tests and isolate external dependencies with mocks/fakes.
- Separate fast unit tests from integration/E2E suites.
- Enforce `go test`, `go fmt`, `goimports`, and `golangci-lint` in CI.
```

## integrations/nextjs-supabase.mdc

```mdc
---
description: Next.js + Supabase integration standards (auth, RLS, typed boundaries)
globs: "app/**/*,services/**/*,supabase/**/*,middleware.ts"
alwaysApply: false
---

# Next.js + Supabase Standards

## Security and auth

- Keep service-role keys server-side only; never expose them to client bundles.
- Enforce Row Level Security (RLS) for user-scoped data access.
- Keep authorization checks server-side even if client guards exist.

## Data boundaries

- Encapsulate Supabase queries in service modules; keep UI/routes thin.
- Validate external input before writes/updates.
- Prefer typed query helpers/contracts to reduce runtime shape drift.

## Reliability and performance

- Keep auth/session flows explicit and resilient across SSR/client transitions.
- Use pagination and selective fields for large datasets.
- Add clear error mapping and user-friendly failure messages at boundaries.

## Realtime and storage

- Use realtime subscriptions intentionally; unsubscribe/cleanup to avoid leaks.
- Validate uploads and enforce storage access policies.
```

## integrations/staffbase.mdc

```mdc
---
description: Staffbase platform – widgets, APIs/SDK, build and runtime (use when working on Staffbase projects)
globs: "*"
alwaysApply: false
---

# Staffbase – Platform Guidelines

Use this rule when working on projects that integrate with **Staffbase** (widgets, APIs/SDK, embedding in Staffbase apps).

## Platform context

- **Staffbase** provides employee apps and communication; projects often ship **widgets** that render inside Staffbase (e.g. Alerts widget, bulletins, custom UIs).
- Widgets integrate with **Staffbase APIs/SDK** and may run in **webviews** (including mobile iOS/Android).
- Build is typically **Vite** library mode → single **IIFE** bundle for embedding.

## Tech stack (typical)

- React 18, TypeScript, Vite/Webpack, Jest.
- Styling: **SCSS** with widget-scoped class prefixes (e.g. `example-widget-*`). Do not introduce Tailwind unless the project already uses it.
- MUI/Emotion where needed for richer UI.

## Build & bundle

- Vite library build → output in `dist/` (see `vite.config.ts`).
- Use `.env`, `.env.staging`, `.env.prod`, `.env.partner` (or equivalent) per environment; align with `package.json` scripts.
- Preferred checks: `pnpm type-check`, `pnpm format`, `pnpm lint` / `pnpm lint:fix`.

## Frontend runtime (critical)

- Widget code runs in the host app and in **mobile webviews** (iOS/Android).
- **Never reference Node globals** (e.g. `process`) at runtime; they can be bundled and cause `"process is not defined"` in browser/webview.
- Use **`import.meta.env`** (Vite) for environment variables and feature flags.
- Avoid patterns like `typeof process !== 'undefined'` in frontend code.

## Backend / Staffbase APIs and SDK

- Integrate with **Staffbase APIs/SDK** via a dedicated `services/` layer (e.g. `apiService`, `widgetService`).
- **Error handling**: robust handling for network failures and slow responses; surface user-friendly errors in the UI.
- Consider **retry/backoff** for idempotent operations only.
- **Security**: do not log sensitive data; validate and sanitize data from APIs.

## Source structure (Staffbase widgets)

- `src/components/` – TSX only; typical subfolders: `config/` (editor/config UI), `elements/` (presentational pieces), `views/` (runtime/editor views).
- `src/configuration/` – JSON schema, UI schema, and config helpers for widget configuration.
- `src/hooks/` – custom hooks (data fetching, widget logic).
- `src/services/` – API and Staffbase SDK access.
- `src/styles/` – shared styles (e.g. drawer, layout).
- `src/types/` – TypeScript types (with subfolders by domain).
- `src/utils/` – stateless utilities.

## Architecture

- **Separation of concerns**: component-based UI; business logic in hooks/services; clear boundaries.
- **Data flow**: unidirectional (parent → child); data fetching and shaping in hooks; callbacks for child → parent.
- **State**: React built-in (useState, useReducer); keep state close to usage; extract complex logic into custom hooks.
- **Performance**: lazy loading/pagination for lists; consider virtualization for large lists; memoization (React.memo, useMemo, useCallback); debounce input-driven filters where appropriate.
- **Integration**: expose a clear API for embedding in Staffbase; use configuration props for customization; handle loading and error states in the UI.

## Styling

- Prefer **SCSS** and existing widget class prefixes; keep styles **scoped to the widget container** so they do not leak into the host page.
- Ensure sufficient **color contrast** and do not rely on color alone for meaning.

## Accessibility

- Keyboard navigation and **ARIA** labeling in interactive components.
- Support screen readers and maintain focus management where relevant.

## Testing

- Jest + React Testing Library for components and hooks.
- **Mock Staffbase SDK and network calls** in tests.

## Error handling

- Wrap async flows in try/catch; surface user-friendly errors in the UI when possible.
- Avoid leaking stack traces or internal details to end users.
```

## integrations/stripe-subscriptions.mdc

```mdc
---
description: Stripe subscription integration standards (webhooks, portal, sync)
globs: "app/**/*,services/**/*,webhooks/**/*,api/**/*"
alwaysApply: false
---

# Stripe Subscriptions Standards

## Core flows

- Keep checkout/subscription creation server-side.
- Use Stripe Customer Portal for subscription self-management when suitable.
- Keep subscription state synchronized with application user/account records.

## Webhooks

- Verify webhook signatures before processing events.
- Make webhook handlers idempotent and retry-safe.
- Handle key subscription events (`created`, `updated`, `deleted`, invoice outcomes).

## Security and reliability

- Store Stripe secrets in secure env vars only.
- Never trust client-reported payment state; trust Stripe events/server checks.
- Log actionable billing context without leaking sensitive payment data.

## Data consistency

- Use transactions/locking where needed to prevent duplicate or conflicting updates.
- Keep a clear mapping model: app user <-> Stripe customer <-> active subscriptions.
```

## javascript.mdc

```mdc
---
description: "Umbrella: JavaScript/TypeScript domain rules (web, extensions, RN, QA, Shopify)"
globs: "*.js,*.mjs,*.cjs,*.ts,*.tsx"
alwaysApply: false
---

# JavaScript Rules (umbrella)

Use **@javascript** when working outside strictly Next.js/React app rules or
when the project includes multiple JS/TS runtimes.

This rule references:

- **General JS/TS**: `.cursor/rules/javascript/general.mdc`
- **Chrome Extensions MV3**: `.cursor/rules/javascript/chrome-extension-mv3.mdc`
- **Modern web apps**: `.cursor/rules/javascript/web-apps.mdc`
- **SvelteKit** (optional): `.cursor/rules/javascript/sveltekit.mdc`
- **React Native/Expo**: `.cursor/rules/javascript/react-native-expo.mdc`
- **Playwright QA**: `.cursor/rules/javascript/playwright-qa.mdc`
- **Shopify theme JS**: `.cursor/rules/javascript/shopify-theme.mdc`

## Short summary

- Security-first input handling and least privilege.
- Prefer TypeScript and explicit boundaries.
- Apply stack-specific rules only when that stack is present.
```

## javascript/chrome-extension-mv3.mdc

```mdc
---
description: Chrome extension MV3 standards (permissions, messaging, CSP, service worker)
globs: "manifest.json,src/**/*.ts,src/**/*.js,extension/**/*.ts,extension/**/*.js"
alwaysApply: false
---

# Chrome Extension MV3 Standards

## Architecture split

- Service worker: orchestration, alarms, storage, background coordination.
- Content scripts: page DOM interaction only.
- Popup/options pages: user interaction and settings; avoid heavy business logic.
- Shared utilities: typed message contracts, validation, logging helpers.

## MV3 requirements

- Background must be a service worker.
- Avoid long-lived in-memory state; persist meaningful state in
  `chrome.storage`.
- Prefer alarms/scheduled APIs over interval loops for recurring work.

## Permissions and privacy

- Apply least-privilege host/API permissions.
- Prefer `activeTab` where viable over broad host permissions.
- Store minimal sensitive data; encrypt only with an explicit threat model.

## Messaging and validation

- Use typed message contracts with discriminated unions.
- Validate payload shape and sender origin before acting.
- Avoid generic "execute arbitrary action" message handlers.

## CSP and resources

- Keep CSP strict (no inline scripts, no remote code execution).
- Minimize `web_accessible_resources` scope to required assets/routes.

## Reliability

- Handle offline and transient failure scenarios explicitly.
- Add tests for messaging/storage orchestration and pure utility logic.
```

## javascript/general.mdc

```mdc
---
description: General JavaScript/TypeScript standards (security, structure, error handling)
globs: "*.js,*.mjs,*.cjs,*.ts,*.tsx"
alwaysApply: true
---

# General JavaScript / TypeScript Standards

## Language defaults

- Prefer TypeScript for non-trivial changes.
- Prefer ES2022+ syntax and modern runtime APIs.
- Use `const` by default, `let` only when mutation is required.
- Prefer named exports over default exports unless framework conventions require
  otherwise.

## Style and naming

- Prefer guard clauses and early returns.
- Use descriptive names with auxiliary verbs (`isLoading`, `hasPermission`,
  `shouldRetry`).
- Keep modules small and focused.

## Architecture

- Prefer functional and declarative patterns.
- Avoid classes unless the runtime pattern strongly benefits from them.
- If classes are used, keep them small with narrow public APIs.

## Errors and logging

- Model expected failures as explicit result values where reasonable.
- Use `try/catch` for exceptional control flow and recovery boundaries.
- Log with actionable context, never secrets/tokens/PII.

## Security baseline

- Treat all external input as untrusted.
- Avoid unsafe execution APIs (`eval`, `new Function`) and unsanitized HTML
  rendering.
- Apply least privilege for permissions, data exposure, and API surface.
```

## javascript/htmx.mdc

```mdc
---
description: HTMX standards (server-driven interactivity with minimal JS)
globs: "*.html,*.php,*.blade.php,*.twig,*.njk"
alwaysApply: false
---

# HTMX Standards

## Interaction model

- Prefer declarative HTMX attributes (`hx-get`, `hx-post`, `hx-put`, `hx-delete`) over custom JS when sufficient.
- Return minimal HTML fragments from server endpoints for targeted updates.
- Use `hx-target` and `hx-swap` intentionally to control DOM replacement semantics.
- Use `hx-trigger` explicitly for non-default interaction timing.

## UX and safety

- Keep server-side validation authoritative; client feedback should mirror server truth.
- Return proper HTTP status codes and clear error fragments for failed interactions.
- Use `hx-confirm` for destructive operations.
- Use `hx-push-url` only when the interaction meaningfully changes navigation state.

## Maintainability

- Keep fragment templates modular and reusable.
- Avoid coupling HTMX endpoints to full-page templates when fragment endpoints are sufficient.
- Document endpoint contract expectations (input, fragment output, error shape).

## Performance

- Keep fragment payloads small and cache where it helps.
- Avoid unnecessary full-region swaps when targeted updates are possible.
```

## javascript/playwright-qa.mdc

```mdc
---
description: Playwright QA standards (locator strategy, determinism, maintainability)
globs: "**/*.spec.ts,**/*.spec.js,tests/**/*.ts,tests/**/*.js"
alwaysApply: false
---

# Playwright QA

## Test design

- Use isolated tests and deterministic fixtures.
- Prefer semantic locators: `getByRole`, `getByLabel`, `getByText`,
  `getByTestId`.
- Prefer `getBy*` and role-based locators over generic `page.locator(...)` selectors.
- Avoid fixed sleeps/timeouts; wait on explicit conditions.
- Prefer web-first assertions (`toBeVisible`, `toHaveText`, etc.) over manual waits.

## Maintainability

- Use helper utilities for repeated setup/flows.
- Use `test.beforeEach`/`test.afterEach` to enforce clean setup/teardown.
- Follow Arrange-Act-Assert structure.
- Prioritize critical user journeys for coverage.
- Keep tests parallel-safe (no shared mutable test state).

## Reliability

- Keep assertions explicit and user-visible.
- Avoid brittle selectors tied to implementation details.
- Keep config concerns in `playwright.config.*` (projects/devices/baseURL/retries).
```

## javascript/react-native-expo.mdc

```mdc
---
description: React Native / Expo JS/TS standards (state, performance, operations)
globs: "app/**/*.tsx,app/**/*.ts,src/**/*.tsx,src/**/*.ts"
alwaysApply: false
---

# React Native / Expo

## Component and state

- Use functional components and hooks.
- Prefer local state by default; promote to global state only when needed.
- For complex transitions, prefer reducer-style state handling.
- For cross-platform navigation layers, keep web/native route contracts explicit (e.g. Solito patterns when used).

## Performance

- Optimize lists (`FlatList`) only when measurable.
- Avoid anonymous render hot-path callbacks when rerender pressure exists.
- Memoize expensive calculations and stable render props where justified.

## Operations

- Plan OTA update safety and rollback strategy when using EAS Updates.
- Handle offline/fetch failures with explicit fallback states.
- Keep localization consistent across platforms (`expo-localization` + i18n stack when present).
```

## javascript/shopify-theme.mdc

```mdc
---
description: Shopify theme JavaScript standards (OS 2.0, SSR-first, dependency-light)
globs: "sections/**/*.liquid,snippets/**/*.liquid,assets/**/*.js,assets/**/*.ts"
alwaysApply: false
---

# Shopify Theme JavaScript (OS 2.0)

## Rendering strategy

- Prefer Liquid/server-rendered HTML first.
- For UI updates, prefer fetching server-rendered fragments over heavy client
  state where possible.

## Dependency strategy

- Keep dependencies minimal; prefer browser-native primitives first.
- Introduce dependencies only when complexity justifies long-term maintenance
  cost.

## Module pattern

- Use module-scoped functions to avoid global leakage.
- If classes are used for theme modules, keep them small with minimal public
  API and private internals.

## DOM and security

- Treat theme settings and merchant input as untrusted content.
- Avoid unsanitized HTML insertion patterns.
- Preserve focus and keyboard accessibility in interactive components.
```

## javascript/sveltekit.mdc

```mdc
---
description: SvelteKit standards (SSR-first, server boundaries, progressive enhancement)
globs: "src/**/*.svelte,src/**/*.ts,src/routes/**/*,svelte.config.*"
alwaysApply: false
---

# SvelteKit Standards

## Rendering and routing

- Prefer SSR/server load functions by default; opt into client behavior intentionally.
- Keep route-level loading and error states explicit.
- Use semantic HTML and progressive enhancement for forms/interactions.

## Data boundaries

- Keep sensitive logic and secrets in server-only modules/routes.
- Validate external input at endpoint/action boundaries.
- Keep client payloads minimal and avoid over-fetching.

## State and structure

- Use stores for shared cross-route state; keep local state local.
- Keep components small and focused; extract reusable logic to utilities.
- Keep file/folder naming consistent and predictable across routes/components.
```

## javascript/web-apps.mdc

```mdc
---
description: Modern web app JS/TS rules (React/Next-agnostic additions)
globs: "*.ts,*.tsx,*.js,*.jsx"
alwaysApply: false
---

# Modern Web Apps

## Component behavior

- Prefer function components and declarative UI patterns.
- Keep side effects minimal and justified.
- Avoid inline handlers only when they reduce readability or create measurable
  rerender churn.

## Data boundaries

- Validate boundary input with schema/type guards.
- Normalize API errors into stable, typed shapes before UI consumption.

## Accessibility baseline

- Use semantic HTML first.
- Ensure keyboard operation and visible focus states for interactive elements.
- Add ARIA only where semantics are insufficient.

## Performance baseline

- Measure before tuning.
- Use memoization (`useMemo`/`useCallback`) only when beneficial.
```

## monorepo.mdc

```mdc
---
description: "Umbrella: Monorepo standards (Turbo workspaces, package boundaries)"
globs: "turbo.json,package.json,pnpm-workspace.yaml,apps/**/*,packages/**/*"
alwaysApply: false
---

# Monorepo Rules (umbrella)

Use **@monorepo** when working on workspace structure, package boundaries, or Turbo pipelines.

This rule references:

- **Turbo workspaces**: `.cursor/rules/monorepo/turbo.mdc` - boundaries, task pipelines, shared config

## Short summary

- Keep package boundaries explicit and avoid cross-app leakage.
- Centralize shared config and scripts where it reduces duplication.
- Keep Turbo tasks deterministic and cache-friendly.
```

## monorepo/turbo.mdc

```mdc
---
description: Turbo monorepo standards (apps/packages boundaries and pipeline discipline)
globs: "turbo.json,package.json,pnpm-workspace.yaml,apps/**/*,packages/**/*"
alwaysApply: false
---

# Turbo Monorepo Standards

## Boundaries

- Keep app-specific code in `apps/*`; move reusable code to `packages/*`.
- Avoid importing app internals from other apps directly.
- Publish shared contracts/types from packages instead of duplicating.

## Pipeline and tasks

- Keep Turbo tasks deterministic and side-effect aware for caching.
- Ensure task inputs/outputs are declared correctly for reliable remote/local cache hits.
- Prefer shared scripts/config at workspace root when behavior is common.

## Dependency hygiene

- Keep package dependencies explicit; avoid hidden transitive reliance.
- Version-lock critical toolchain dependencies for reproducible CI.
- Add lightweight package-level checks/tests where they prevent regressions early.
```

## n8n.mdc

```mdc
---
description: "Umbrella: n8n workflow design and MCP tools"
globs: "*.json"
alwaysApply: false
---

# n8n Rules (umbrella)

Use **@n8n** when designing, building, or validating n8n workflows with n8n-MCP tools.

This rule references:

- **n8n MCP**: `.cursor/rules/n8n/n8n-mcp.mdc` — silent/parallel execution, templates first, validation levels, explicit parameters, addConnection/batch syntax

## Short summary

- Templates first; validate at multiple levels; set all parameters explicitly; use batch operations for updates; mandatory template attribution.
```

## n8n/n8n-mcp.mdc

```mdc
---
description: n8n workflow design and validation with n8n-MCP tools
globs: "*.json"
alwaysApply: false
---

# n8n Workflow Rules (MCP)

When using n8n-MCP tools to design, build, or validate n8n workflows:

## Core Behavior

1. **Silent execution** — Run tools without commentary; respond after all tools complete.
2. **Parallel execution** — Call independent operations (e.g. search_nodes, get_node, search_templates) in parallel.
3. **Templates first** — Check templates before building from scratch.
4. **Multi-level validation** — Use `validate_node(mode='minimal')` → `validate_node(mode='full')` → `validate_workflow`.
5. **Never trust defaults** — Explicitly configure ALL parameters that control node behavior; default values are a common source of runtime failures.

## Process

1. **Discovery** — Use `tools_documentation()`; search_templates (by_metadata, by_task, by_nodes) and search_nodes in parallel when needed.
2. **Configuration** — get_node with detail level and includeExamples when useful; show workflow architecture for approval before building.
3. **Validation** — validate_node (minimal then full, profile 'runtime'); fix all errors before proceeding.
4. **Building** — If using a template, get_template and **mandatory attribution** (author name, username, n8n.io link). Set ALL parameters explicitly; connect nodes; add error handling; use n8n expressions ($json, $node["NodeName"].json).
5. **Workflow validation** — validate_workflow, validate_workflow_connections, validate_workflow_expressions before deployment.
6. **Deployment** — n8n_create_workflow; n8n_validate_workflow; n8n_update_partial_workflow for batch updates; n8n_test_workflow.

## Critical Syntax

- **addConnection** (partial workflow updates): use four **separate string** parameters — `source`, `target`, `sourcePort`, `targetPort` (not an object, not combined strings).
- **IF node routing**: use the `branch` parameter (`"true"` or `"false"`) to route to the correct output.
- **Batch updates**: use one `n8n_update_partial_workflow` call with an `operations` array for multiple changes.

## Response

- No commentary between tool runs; after tools complete, summarize what was created or updated and validation result.
```

## nextjs.mdc

```mdc
---
description: "Umbrella: Next.js App Router standards (routing, data, actions, performance)"
globs: "app/**/*,components/**/*"
alwaysApply: false
---

# Next.js Rules (umbrella)

Use **@nextjs** when working primarily on App Router architecture and flows.

This rule references:

- **Core App Router**: `.cursor/rules/nextjs/nextjs.mdc` - RSC defaults, special-file conventions
- **Route handlers**: `.cursor/rules/nextjs/route-handlers.mdc` - thin handlers and placement
- **API responses**: `.cursor/rules/nextjs/api-response-shapes.mdc` - JSON response contracts
- **Data fetching**: `.cursor/rules/nextjs/data-fetching.mdc` - RSC-first and waterfall prevention
- **Forms/actions**: `.cursor/rules/nextjs/forms-and-actions.mdc` - Zod, RHF/next-safe-action when present
- **Performance**: `.cursor/rules/nextjs/rendering-performance.mdc` - dynamic imports, image/script strategy
- **Error/observability**: `.cursor/rules/nextjs/error-observability.mdc` - boundaries and logging

## Short summary

- RSC-first architecture with minimal client islands.
- Boundary validation + typed action/response shapes.
- Intentional caching/fetching and clear loading/error UX.
```

## nextjs/api-response-shapes.mdc

```mdc
---
description: API response shapes (agent-optimized)
globs: "app/api/**/route.ts"
alwaysApply: true
---

# API Response Shapes

## Goal

Keep API responses predictable, typed, and easy to consume.

## Standard JSON Shapes

Prefer one of these:

- **Success**:
  - `Response.json({ data })`
- **Error**:
  - `Response.json({ error: { code, message } }, { status })`

## Status Codes

- `200`: OK
- `201`: Created
- `204`: No content (no JSON body)
- `400`: Validation / bad request
- `401`: Unauthorized
- `403`: Forbidden
- `404`: Not found
- `409`: Conflict
- `500`: Unexpected server error

## Rules

- Never return unvalidated request input.
- Do not throw for expected errors; return `{ error }` with an explicit status.
- Keep mapping minimal inside the route handler; do it in `services/` when possible.
```

## nextjs/data-fetching.mdc

```mdc
---
description: Next.js data fetching strategy (RSC-first, caching intent, waterfall prevention)
globs: "app/**/*.tsx,app/**/*.ts,services/**/*.ts"
alwaysApply: true
---

# Data Fetching Strategy

## Defaults

- Prefer server-side fetching in Server Components, route handlers, or server
  actions.
- Avoid client-side fetching for data that can be rendered on the server.

## Waterfall prevention

- Start independent async work early and resolve in parallel with
  `Promise.all`.
- Avoid sequential awaits when data sources do not depend on each other.
- Consider preload patterns only when they clearly reduce latency.

## Caching intent

- Decide caching behavior intentionally for each flow.
- Avoid accidental stale UI by documenting if a route is dynamic, revalidated,
  or fully static.
- Keep cache logic out of UI components when possible.

## Client cache usage

- Use TanStack Query only when client cache/sync/optimistic updates are
  required.
- Do not add query state layers to simple server-rendered flows.
```

## nextjs/error-observability.mdc

```mdc
---
description: Next.js error handling and observability (boundaries, context-rich logs)
globs: "app/**/*.tsx,app/**/*.ts,services/**/*.ts"
alwaysApply: true
---

# Error Handling and Observability

## UI boundaries

- Use `error.tsx` for route-level failures.
- Use `global-error.tsx` for app-level unexpected failures.
- Keep fallback UI actionable and user-friendly.

## Expected vs unexpected errors

- Expected failures should return typed values where possible.
- Unexpected failures should throw and be captured by boundaries/logging.

## Logging

- Log errors with actionable context (operation, identifiers, boundary).
- Never log secrets, tokens, or sensitive personal data.

## Sentry (optional)

- If Sentry is already configured, use it for unexpected errors and key
  execution context.
- Do not add observability dependencies unless needed by the project.
```

## nextjs/forms-and-actions.mdc

```mdc
---
description: Forms and server action integration (Zod, RHF, next-safe-action)
globs: "app/**/*.tsx,app/**/*.ts,components/**/*.tsx,services/**/*.ts"
alwaysApply: false
---

# Forms and Actions

## Validation-first forms

- Validate form input at boundaries.
- If the repo already uses Zod, prefer Zod schemas + inferred types.
- Keep user-facing validation messages specific and actionable.

## React Hook Form (optional)

- If React Hook Form is already in the repo, prefer it for non-trivial forms.
- Do not introduce RHF for tiny one-field forms unless consistency requires it.

## Server actions integration

- Prefer typed server actions for form submissions.
- If `next-safe-action` is present, prefer it for action typing and safe input
  handling.
- Keep a consistent action result shape:
  - success: `{ ok: true, data }`
  - failure: `{ ok: false, error: { code, message } }`

## Error model

- Expected validation/domain failures return typed results.
- Unexpected failures throw and are handled by boundaries.
```

## nextjs/nextjs.mdc

```mdc
---
description: Next.js App Router rules (agent-optimized)
globs: "app/**/*"
alwaysApply: true
---

# Next.js (App Router) Rules

## Server vs Client Components

- `app/**/page.tsx` and `app/**/layout.tsx` are **Server Components by default**.
- Use **Client Components** only when you need:
  - State and event handlers (`onClick`, `onChange`)
  - Effects (`useEffect`)
  - Browser-only APIs (`window`, `localStorage`, etc.)
- `'use client'` creates a **boundary**: the file and all of its imports become part of the client bundle.
  - Keep client islands small to reduce JS shipped to the browser.

## Passing Data

- Props passed from Server -> Client must be **serializable**.

## Route UX Files

- If a route fetches data or is non-trivial, include `loading.tsx` and `error.tsx` for consistent UX and error boundaries.
- Add `global-error.tsx` for app-level unexpected failures.

## Metadata APIs

- Prefer App Router metadata APIs (`metadata`, `generateMetadata`) over legacy `<Head />` patterns.

## Built-in Components

- Use `<Link />` for internal navigation.
- Use `<Image />` for user-facing images with explicit dimensions.
- Use `<Script />` for third-party scripts instead of ad-hoc script tags.

## Protecting Server-only Code

- Avoid importing server-only code (secrets, DB calls) into Client Components.
- If needed later, consider marking modules with `server-only` / `client-only` (optional).

## Caching intent

- Route/data caching must be explicit and intentional; avoid accidental stale behavior.

## Next Special Files: allowed extra exports

These rules enforce "one export per file" for your own modules, **but Next.js special files require extra exports**.

Allowed exceptions:

- `app/**/layout.tsx`, `app/**/page.tsx`: `default export` + `metadata` / `generateMetadata` / `viewport` (and similar Next file-convention exports).
- `app/api/**/route.ts`: multiple HTTP method exports (GET/POST/...) + route config exports.

## References

- Route Handlers: `.cursor/rules/nextjs/route-handlers.mdc`
- Server Actions: `.cursor/rules/nextjs/server-actions.mdc`
- Forms/Actions: `.cursor/rules/nextjs/forms-and-actions.mdc`
- Data Fetching: `.cursor/rules/nextjs/data-fetching.mdc`
- Rendering/Performance: `.cursor/rules/nextjs/rendering-performance.mdc`
- Error/Observability: `.cursor/rules/nextjs/error-observability.mdc`
- Boundaries: `.cursor/rules/core/boundaries.mdc`
```

## nextjs/rendering-performance.mdc

```mdc
---
description: Next.js rendering and performance defaults (RSC-first, dynamic imports, web vitals)
globs: "app/**/*.tsx,components/**/*.tsx"
alwaysApply: true
---

# Rendering and Performance

## Rendering model

- Prefer Server Components by default.
- Add `'use client'` only for interactivity, browser APIs, or client-only
  libraries.
- Keep client islands small and focused.

## Dynamic imports

- Use `dynamic()` + Suspense for non-critical client features that benefit from
  split loading.
- Do not add dynamic boundaries when they increase complexity without measurable
  benefit.

## Images and scripts

- Use `<Image />` with explicit dimensions or `fill`.
- Lazy-load non-critical images.
- Use `<Script />` only when third-party scripts are required.

## Web Vitals focus

- Optimize LCP, CLS, and INP for user-visible pages.
- Prefer changes that improve default rendering and payload size before
  introducing micro-optimizations.
```

## nextjs/route-handlers.mdc

```mdc
---
description: Next.js Route Handlers (thin handlers, service boundaries)
globs: "app/api/**/route.ts"
alwaysApply: true
---

# Route Handlers (App Router)

## Placement & Conflicts

- Route handlers live in `app/**/route.ts`.
- You **cannot** have `route.ts` and `page.tsx` in the same route segment.

## Thin Handler Rule (STRICT)

Route handlers must be thin:

- Parse/validate request input
- Call a `services/<area>/...` function
- Return an explicit response

No business logic, no DB/network access directly in the handler.

## HTTP Methods

- Supported: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS`.

## Caching Model (docs-aligned)

- Route handlers are **not cached by default**.
- Only `GET` can opt into caching.

## Cache Components Note

- If Cache Components is enabled later:
  - `GET` handlers follow the same model as UI routes.
  - `use cache` **cannot** be used directly inside a Route Handler body; extract it to a helper function.

## References

- Response shapes: `.cursor/rules/nextjs/api-response-shapes.mdc`
- Validation: `.cursor/rules/api/validation.mdc`
- utils vs services: `.cursor/rules/backend/services-and-utils.mdc`
```

## nextjs/server-actions.mdc

```mdc
---
description: Next.js server actions standards (validation, response shape, expected errors)
globs: "app/**/actions.ts,app/**/actions/**/*.ts,app/**/*action*.ts,app/**/*action*.tsx"
alwaysApply: false
---

# Server Actions Standards

## Goal

Keep server actions predictable, typed, and safe at boundaries.

## Validation

- Validate external input before business logic.
- If the repo already uses Zod, prefer Zod schemas + inferred types.
- Keep validation at the boundary; services enforce domain invariants.

## Expected vs unexpected failures

- Expected failures: return typed result objects.
- Unexpected failures: throw and let boundaries/error handling capture context.
- Do not rely on exception strings for control flow.

## Response shape (recommended)

Use a consistent action result shape:

- Success: `{ ok: true, data }`
- Failure: `{ ok: false, error: { code, message } }`

## next-safe-action (optional)

- If `next-safe-action` is already in the project, prefer it for typed server actions.
- Do not add it for trivial flows that are already safe and simple.
```

## php.mdc

```mdc
---
description: "Umbrella: PHP standards (general + Laravel + WordPress + Drupal)"
globs: "*.php,composer.json"
alwaysApply: false
---

# PHP Rules (umbrella)

Use **@php** when working on PHP codebases.

This rule references:

- **General PHP**: `.cursor/rules/php/general.mdc` - baseline language, architecture, security, testing
- **Laravel**: `.cursor/rules/php/laravel.mdc` - Laravel service/container, validation, queues, policies
- **Laravel + Livewire** (optional): `.cursor/rules/php/laravel-livewire.mdc` - Livewire components, UX feedback, component boundaries
- **Laravel + Vue** (optional): `.cursor/rules/php/laravel-vue.mdc` - Inertia/SPA boundaries, API contracts, frontend-state discipline
- **WordPress**: `.cursor/rules/php/wordpress.mdc` - WP APIs, nonces/capabilities, escaping/sanitization
- **Drupal**: `.cursor/rules/php/drupal.mdc` - Drupal services, Form API, cache metadata, module patterns

## Short summary

- Keep entry layers thin, move business logic to services.
- Validate at boundaries, escape at output boundaries.
- Prefer framework-native APIs over custom plumbing.
```

## php/drupal.mdc

```mdc
---
description: Drupal standards (services, entities, Form API, cache metadata, and DI)
globs: "web/modules/**/*.php,modules/**/*.php,*.module,*.install,*.services.yml,*.routing.yml"
alwaysApply: true
---

# Drupal Standards

## Platform constraints

- Target the project's Drupal major/minor support (Drupal 10/11 era projects).
- Follow project PHP constraints from `composer.json`.
- Keep dependencies Composer-managed.

## Drupal-native APIs first

- Prefer Entity API and Field API for content/domain data.
- Use Config API for configuration (avoid ad-hoc config stores).
- Use Cache API and cache metadata correctly (tags, contexts, max-age).
- Use Queue API for deferred/background work.
- Use logger channel services (`logger.factory`) for logs.

## Architecture

- Keep controllers/forms/plugins thin and focused.
- Move business and integration logic to services.
- Use plugin system for extensibility points.
- Prefix service/plugin IDs with module namespace.

## Dependency injection

- Register services in `MODULE.services.yml`.
- Prefer constructor injection.
- Avoid `\Drupal::service()` in new code except legacy glue boundaries.

## Data and schema

- Use Entity API when possible.
- For custom tables, define schema (`hook_schema`) and evolve with update hooks.
- Use Database API query builders/parameterized queries.

## Forms and security

- Use Form API validation/submit handlers.
- Keep state-changing operations permission-checked.
- Escape/sanitize output appropriately for render context.

## Testing

- Use Drupal testing layers (unit/kernel/functional) based on scope.
- Cover service logic and module integration boundaries.
```

## php/general.mdc

```mdc
---
description: General PHP standards (security-first, typed code, thin entry layers)
globs: "*.php,composer.json"
alwaysApply: true
---

# General PHP Standards

## Baseline

- Prefer PHP 8.3+ when stack constraints allow.
- Match project/platform constraints when a framework requires lower versions.
- Use PSR-12 unless the framework enforces a stricter variant.

## Language rules

- Use `declare(strict_types=1);` in owned PHP files where compatibility allows.
- Prefer typed properties, parameter/return types, readonly constructs, and `match` where appropriate.
- Prefer composition over inheritance.
- Avoid shared mutable static state.

## Architecture

- Keep controllers/endpoints/entrypoints thin.
- Place business rules in services/use-cases.
- Isolate infrastructure concerns (DB/HTTP/filesystem) behind explicit adapters/services.
- Use DI/service containers where available.

## Errors and logging

- Model expected failures as typed results or domain-level exceptions.
- Use `try/catch` only to recover, translate, or add context.
- Log actionable context (request/entity/user identifiers) without secrets.

## Security (mandatory)

- Validate external input first, sanitize/normalize where needed, escape at output.
- Use parameterized queries and framework DB abstractions.
- Treat HTTP, CLI args, webhook payloads, and imported data as untrusted.
- Avoid unsafe unserialize, dynamic includes, and shell execution without strict controls.

## Testing

- Unit tests for business logic/services.
- Integration tests for DB/HTTP/framework boundaries.
- Prefer fixtures/factories over coupling to production-like data dumps.
```

## php/laravel-livewire.mdc

```mdc
---
description: Laravel + Livewire standards (component boundaries and UX state)
globs: "app/Livewire/**/*.php,resources/views/livewire/**/*.blade.php,resources/views/**/*.blade.php"
alwaysApply: false
---

# Laravel + Livewire

## Component architecture

- Keep Livewire components focused and small; extract domain logic to services/actions.
- Use Livewire for server-driven interactivity; avoid duplicating the same state logic in Alpine and Livewire.
- Prefer explicit component names and predictable public properties/actions.

## Validation and state

- Validate inputs at component/action boundaries (Form Requests or Livewire validation rules).
- Use loading/disabled states (`wire:loading`, `wire:target`) for async actions.
- Keep side effects explicit; avoid hidden state mutation across unrelated hooks.

## Security and rendering

- Authorize mutations with Policies/Gates in component actions.
- Treat component input as untrusted; sanitize/validate before persistence.
- Escape output by default in Blade; only render raw HTML when explicitly sanitized.

## Testing

- Add focused Livewire component tests for critical UI flows.
- Keep feature tests for end-to-end behavior across HTTP + Livewire boundaries.
```

## php/laravel-vue.mdc

```mdc
---
description: Laravel + Vue standards (API boundaries, SPA contracts, and state)
globs: "app/**/*.php,routes/**/*.php,resources/js/**/*.{js,ts,vue}"
alwaysApply: false
---

# Laravel + Vue

## Boundary design

- Keep backend/frontend boundary explicit: controllers/resources define stable contracts.
- Prefer API Resources (or Inertia props contracts) over ad-hoc array payloads.
- Version public API contracts when backward compatibility matters.

## Frontend integration

- Keep Vue components presentational when possible; move data orchestration to composables/stores.
- Avoid duplicating validation rules inconsistently between frontend and backend.
- Use route-level code splitting and lazy loading for heavy pages/features.

## Security and auth

- Keep sensitive checks on server-side policies/gates.
- Use Laravel auth stack consistently (Sanctum/Passport/session) and avoid custom token flows unless justified.
- Keep CSRF protection enabled for state-changing flows.

## Data and performance

- Prevent N+1 on backend and over-fetching on frontend.
- Cache expensive backend queries intentionally and document invalidation.
- Paginate large collections and stream/chunk heavy exports/jobs.
```

## php/laravel.mdc

```mdc
---
description: Laravel standards (framework-native validation, authz, queues, and API boundaries)
globs: "app/**/*.php,bootstrap/**/*.php,routes/**/*.php,config/**/*.php,database/**/*.php,tests/**/*.php"
alwaysApply: true
---

# Laravel Standards

## Platform constraints

- Prefer current stable Laravel major supported by the project (Laravel 12+ in modern projects).
- Prefer PHP 8.2+ (8.3+ when compatible with dependencies and hosting).

## Architecture

- Controllers should be thin orchestration layers.
- Keep business logic in services/actions/domain classes.
- Use constructor DI/method injection over static facades in core business paths.
- Use repositories only when persistence complexity justifies the extra layer.
- Keep controllers and services cohesive; split classes that accumulate unrelated responsibilities.

## Framework-native primitives

- Validation: Form Requests.
- Authorization: Policies/Gates.
- Background jobs: Queues/Jobs (Horizon when available).
- Response shaping: API Resources.
- Decoupling: Events/Listeners where useful.

## Data and persistence

- Use Eloquent for standard CRUD and relationships.
- Use Query Builder when complex SQL is clearer than Eloquent chains.
- Use `DB::transaction()` for multi-step data integrity.
- Keep migrations reversible and indexed intentionally.
- Use pagination helpers for list endpoints (`paginate`, `cursorPaginate`) instead of ad-hoc paging.

## API and contracts

- For public APIs, define explicit versioning strategy (path/header) and keep it consistent.
- Use API Resources/Transformers as the boundary contract; avoid leaking internal model structure.
- Normalize expected failures to stable response shapes and status codes.

## Performance and operations

- Use caching intentionally (`Cache::remember`, tags/locks where appropriate); document invalidation strategy.
- Move long-running or retryable work to jobs/queues; keep web requests fast.
- Use Scheduler for recurring tasks; keep schedule definitions deterministic and observable.
- Favor eager loading and query profiling to avoid N+1 issues.

## Security and reliability

- Keep CSRF enabled for state-changing web flows.
- Rate-limit public endpoints where abuse is possible.
- Never expose secrets in responses/logs.
- Use signed URLs for sensitive temporary links where appropriate.
- Prefer built-in auth/authz primitives (Sanctum/Passport/Policies/Gates) over custom security plumbing.

## Conventions

- Follow Laravel naming conventions: singular Models (e.g. `User`), intent-based controllers (e.g. `UserController`).
- Use `snake_case` for DB columns and config keys; follow project convention for PHP variables/methods.
- Preserve existing PHPDoc/comments unless they are inaccurate; update instead of deleting by default.

## Testing

- Unit + feature tests with PHPUnit/Pest.
- Use factories and isolated test databases.
- Add browser/E2E tests only for critical end-user flows.
```

## php/wordpress.mdc

```mdc
---
description: WordPress standards (WPCS, hooks/APIs, nonces, escaping, and safe persistence)
globs: "wp-content/**/*.php,*.php"
alwaysApply: true
---

# WordPress Standards

## Platform constraints

- Follow project WordPress/PHP compatibility matrix first.
- Prefer modern PHP targets where hosting and plugin ecosystem permit.

## WordPress-native APIs first

- Use actions/filters for extensibility.
- Prefer REST API for modern integrations over legacy AJAX patterns.
- Use Options API / Transients API / metadata APIs where appropriate.
- Prefer `WP_Query` and core query helpers over direct SQL when possible.

## Architecture

- Never modify WordPress core.
- Keep business logic in plugin modules/classes; keep templates focused on presentation.
- Use child themes for theme-level customization.

## Security

- Sanitize/validate all input with WP helpers (`sanitize_*` and dedicated validators).
- Escape all output (`esc_html`, `esc_attr`, `esc_url`, etc.).
- Use nonces for state-changing requests and verify them server-side.
- Check capabilities (`current_user_can`) before mutations.

## Database

- If using `$wpdb`, always use `$wpdb->prepare()` for dynamic values.
- Avoid direct string interpolation in SQL.
- Version schema changes and apply via upgrade routines (`dbDelta` when suitable).

## Assets and performance

- Enqueue assets via `wp_enqueue_script` / `wp_enqueue_style`.
- Version assets intentionally for cache busting.
- Cache expensive operations with transients/object cache when available.

## i18n and testing

- Use WP i18n functions (`__`, `_e`, `esc_html__`, etc.) and load text domains correctly.
- Test hooks and REST endpoints with WordPress test tooling where available.
```

## python.mdc

```mdc
---
description: "Umbrella: Python schema-driven development and UV"
globs: "*.py"
alwaysApply: false
---

# Python Rules (umbrella)

Use **@python** when working on Python code.

This rule references:

- **Python standards**: `.cursor/rules/python/python.mdc` — schema-first, UV, type hints, structure, testing, packaging
- **Django** (optional): `.cursor/rules/python/django.mdc` — app structure, ORM-first, MVT boundaries, security
- **Django REST API** (optional): `.cursor/rules/python/django-rest-api.mdc` — DRF serializers/views, versioning, pagination, error shape

## Short summary

- Schema first; UV for venv and packages (uv venv, uv pip sync/compile); strict pinning; type hints and validation.
```

## python/django-rest-api.mdc

```mdc
---
description: Django REST API standards (DRF design, contracts, authz, pagination)
globs: "**/api/**/*.py,**/serializers.py,**/views.py,**/permissions.py,**/urls.py"
alwaysApply: false
---

# Django REST API Standards

## API design

- Follow RESTful semantics with clear method/status usage.
- Keep API versioning explicit and consistent (prefer URL-based versioning).
- Keep response contracts stable and documented.
- Use standardized success/error response shapes across endpoints.

## DRF layers

- Use serializers for validation + transformation, not just output formatting.
- Keep API views/viewsets focused on transport orchestration.
- Move domain rules to models/managers/services instead of bloating views.
- Use reusable permissions and validators for shared rules.

## Security

- Enforce authentication + authorization for every protected endpoint.
- Prefer framework-native auth stacks (Session/Auth headers/JWT libs already used).
- Validate/sanitize external input at boundaries; never trust client payloads.

## Performance and operability

- Apply pagination consistently for list endpoints.
- Prevent N+1 and monitor query counts in API hot paths.
- Use caching for expensive read paths with clear invalidation strategy.
- Add structured logs for request id, latency, status, and error context.

## Error handling

- Use centralized exception handling for predictable API error shape.
- Map validation/auth/domain errors to appropriate HTTP status codes.
```

## python/django.mdc

```mdc
---
description: Django standards (modular apps, ORM-first, security and performance)
globs: "*.py,**/templates/**/*.html"
alwaysApply: false
---

# Django Standards

## Architecture

- Organize code by Django apps with clear boundaries and reusable modules.
- Keep views thin; move business logic to models/managers/services.
- Use MVT boundaries consistently (Model-View-Template).
- Prefer CBVs for complex flows and FBVs for small/simple endpoints.

## Data and ORM

- Prefer Django ORM over raw SQL; use raw SQL only for proven performance cases.
- Prevent N+1 queries with `select_related` and `prefetch_related`.
- Add explicit DB indexes for high-frequency query/filter fields.
- Use `transaction.atomic()` for multi-step data integrity operations.

## Validation and forms

- Use Django forms/model forms for form workflows and validation.
- Keep validation close to boundaries (forms/serializers/model validation).
- Return actionable validation errors for users and clients.

## Security and reliability

- Keep CSRF/XSS/SQL injection protections enabled and verify template escaping.
- Use Django auth framework and permission checks instead of custom auth plumbing.
- Handle expected failures explicitly and log context without secrets.
- Provide custom 404/500 error pages with safe, useful UX.

## Performance

- Use caching intentionally for frequently accessed data/views.
- Offload long-running I/O tasks to async workers (Celery or equivalent).
- Keep static/media handling production-ready (e.g., WhiteNoise/CDN strategy).
```

## python/python.mdc

```mdc
---
description: Python schema-driven development and UV-based tooling
globs: "*.py"
alwaysApply: false
---

# Python Standards (Schema-Driven + UV)

## Core Principles

- **Schema first**: Define data models and interfaces in schemas before implementation.
- **UV for environments**: Use `uv venv` (not `pip venv`); use `uv pip` for install/sync/compile.
- **Strict pinning**: Pin dependencies strictly; use `uv pip sync` with requirements; use `uv pip compile` for requirements.
- **Type hints**: Use type hints consistently; generate type stubs from schemas when applicable.

## Project Structure

- Use proper package layout (e.g. `src/` layout).
- Follow PEP 8, 484, 517, 621.
- Define types in central schema; avoid ad-hoc types and circular imports.
- Maintain schema-to-code documentation.

## Code Organization

- Define interfaces in schemas; implement clean architecture; follow SOLID.
- Use absolute imports over relative where appropriate.
- Document code and schemas; keep schema and docs synchronized.
- Never write implementations before schemas; never mix package boundaries.

## Dependency Management

- Use UV for all package operations (uv pip sync, uv pip compile).
- Do not use `pip` directly or global packages.
- Handle dev dependencies separately; version interfaces; update with validation.

## Testing & Validation

- Define validation rules in schemas; write unit tests against schemas.
- Implement integration tests; use proper fixtures; test edge cases and error scenarios.
- Generate validators from schemas; do not skip schema validation or test isolation.

## Quality

- Use schema-based generators where helpful; implement proper linting and style guides.
- Use static analysis; monitor complexity; validate generated code.
- Use structured logging; handle errors with schema validation where appropriate.

## Packaging

- Use proper packaging (pyproject.toml); handle versioning for schemas and code.
- Include schema metadata; provide schema validation tools; maintain UV-compatible requirements.
```

## react.mdc

```mdc
---
description: "Umbrella: React standards (architecture, hooks, state, a11y, forms, performance)"
globs: "components/**/*,hooks/**/*,stores/**/*,*.tsx,*.ts"
alwaysApply: false
---

# React Rules (umbrella)

Use **@react** when working on React components, hooks, state, forms, and UI behavior.

This rule references:

- **Architecture**: `.cursor/rules/react/react-architecture.mdc` - placement and splitting rules
- **Component patterns**: `.cursor/rules/react/component-patterns.mdc` - component structure and boundaries
- **Hooks**: `.cursor/rules/react/hooks-guide.mdc` - hook discipline and helper extraction
- **State**: `.cursor/rules/react/state-management.mdc` - local vs shared state patterns
- **URL/server state**: `.cursor/rules/react/url-server-state.mdc` - URL/query and server-state strategy
- **Accessibility**: `.cursor/rules/react/accessibility.mdc` - semantic, keyboard, and form accessibility
- **Naming**: `.cursor/rules/react/naming.mdc` - handler/boolean/hook naming conventions
- **Performance**: `.cursor/rules/react/performance.mdc` - memoization and render hygiene
- **Forms/validation**: `.cursor/rules/react/forms-validation.mdc` - Zod + RHF usage guidelines
- **Security**: `.cursor/rules/react/security.mdc` - UI-side XSS and untrusted HTML rules
- **Testing**: `.cursor/rules/react/testing.mdc` - opt-in React testing approach

## Short summary

- Functional components and hooks with small, focused files.
- Accessibility and predictable state handling by default.
- Validation, performance, and security rules applied pragmatically.
```

## react/accessibility.mdc

```mdc
---
description: React accessibility baseline (semantic HTML, keyboard support, forms)
globs: "*.tsx"
alwaysApply: true
---

# Accessibility Baseline

## Semantics first

- Prefer semantic elements (`button`, `a`, `nav`, `main`, `header`, `section`) over generic `div` wrappers.
- Do not use a `div` as a button unless unavoidable.

## Keyboard and focus

- Interactive UI must be operable with keyboard.
- Preserve visible focus states; do not remove focus outlines without an accessible replacement.

## ARIA usage

- Add ARIA only when semantics are insufficient.
- Keep `aria-label`/`aria-describedby` aligned with visible intent.

## Forms

- Inputs need accessible labels.
- Validation and error messages must be programmatically associated with fields.

## Contrast

- Ensure text and interactive controls maintain accessible contrast in light and dark themes.
```

## react/component-patterns.mdc

```mdc
---
description: React component patterns (strict one-component-per-file)
globs: "*.tsx"
alwaysApply: true
---

# React Component Patterns (strict)

## Component Organization

- **UI components** (`components/ui/`): primitive, reusable, no business logic (Button, Modal, Panel).
- **Feature components** (`components/<area>/`): organize by domain (app shell, feature-specific UI, shared).

## Component Guidelines

- Keep components small (<100 lines preferred, <200 max); extract sub-components when complexity grows.
- Prefer components that orchestrate small, single-purpose helpers and hooks.

## One Component Per File (STRICT)

- Exactly one exported component per `.tsx` file.
- No helper functions inside component files; extract to `utils/`.
- No inline types; import from `types/`.

## Client vs Server (App Router)

- Prefer Server Components by default.
- Add `'use client'` only when needed (state/effects/event handlers).

## Folder Namespacing

For complex components with children:

- `components/<area>/Parent/Parent.tsx`
- `components/<area>/Parent/Header.tsx`
- `components/<area>/Parent/Footer.tsx`

Avoid repeating the parent name in child filenames.

## Performance

- Memoize expensive computations with `useMemo`.
- Use `useCallback` for handlers passed to children to avoid unnecessary re-renders.
- Consider `React.memo` for purely presentational components.

## Accessibility

- Use semantic HTML where appropriate.
- Add ARIA attributes when needed.
- Support keyboard navigation where applicable.
- Maintain sufficient color contrast.

## Testing

- Don't write tests if not requested.
- Prefer tests next to or under the component (e.g. `__tests__` or colocated test files).
- Use React Testing Library for component tests; cover behaviour and rendering.
```

## react/forms-validation.mdc

```mdc
---
description: React forms and validation strategy (Zod, RHF optional)
globs: "*.tsx,components/**/*.tsx,hooks/**/*.ts,services/**/*.ts"
alwaysApply: true
---

# Forms and Validation

## Validation baseline

- Use schema-based validation for external/user input boundaries.
- If Zod is present in the repo, prefer Zod schema + inferred types.
- Return clear, user-facing validation messages.

## React Hook Form (optional)

- If RHF is present in the project, prefer it for non-trivial forms.
- Do not force RHF for tiny forms where simple local state is clearer.

## Form architecture

- Keep field UI, schema, and submission flow coherent.
- Avoid duplicating validation logic between UI and boundary services.
```

## react/hooks-guide.mdc

```mdc
---
description: React Hooks best practices (strict one-hook-per-file)
globs: "*.ts,*.tsx"
alwaysApply: true
---

# Hooks Best Practices (strict)

## One Hook Per File (STRICT)

- Exactly one exported hook per file: `hooks/<area>/useXxx.ts`.
- No extra exports.

## No Helpers Inside Hooks (STRICT)

- Hooks contain only state/effects/memos and call helpers imported from `utils/`.
- Any helper must be its own file (one exported function per file).
- Hooks should orchestrate small, single-purpose helpers rather than doing multiple tasks inline.

## No Types Inside Hooks (STRICT)

- Do not define `interface`/`type` in hook files.
- Hook params/return types live in `types/<area>/...` (one type per file).

## Stable API

- Return the minimal meaningful shape.
- Prefer stable references for handlers/derived values (`useCallback`, `useMemo`).

## Side Effects

- Fetch/subscribe in `useEffect` with cleanup.
- Avoid implicit dependencies; keep dependency arrays correct and as small as possible.

## Organization

- Group related hooks in subdirectories under `hooks/<area>/` when it improves discoverability.
```

## react/naming.mdc

```mdc
---
description: React naming conventions for handlers, booleans, and hooks
globs: "*.tsx,hooks/**/*.ts,components/**/*.tsx"
alwaysApply: true
---

# React Naming

## Handlers

- Event handlers must start with `handle`:
  - `handleClick`
  - `handleSubmit`
  - `handleKeyDown`

## Booleans

- Use auxiliary-verb names:
  - `isLoading`
  - `hasError`
  - `canSubmit`
  - `shouldRetry`

## Hooks

- Hooks must start with `use`:
  - `useAuth`
  - `useFormState`
  - `useUserSettings`
```

## react/performance.mdc

```mdc
---
description: React rendering performance rules (pragmatic, measure-first)
globs: "*.tsx,components/**/*.tsx,hooks/**/*.ts"
alwaysApply: true
---

# React Performance

## Core approach

- Optimize for readability first; measure before tuning.
- Avoid premature memoization and abstraction.

## Memoization

- Use `useMemo` for expensive derived values.
- Use `useCallback` when stable function identity matters.
- Use `React.memo` only for components with stable props and demonstrated rerender pressure.

## JSX patterns

- Avoid inline handlers only when they cause meaningful rerender churn or break memoization.
- Prefer clarity when performance impact is negligible.

## Lists and keys

- Never use array index as key unless the list is static and order never changes.
```

## react/react-architecture.mdc

```mdc
---
description: React + TypeScript architecture (App Router, strict file discipline)
globs: "*.ts,*.tsx"
alwaysApply: true
---

# React + TypeScript Architecture

## Defaults (App Router)

- Prefer **Server Components** by default.
- Add `'use client'` only when you need client-side state/effects/event handlers.
- Route handlers live in `app/api/**/route.ts` and must be thin (logic goes to `services/`).

## File Discipline (STRICT)

- One exported component per `.tsx`.
- No helper functions inside components.
- No inline types; import from `types/`.

## Splitting Guidance

- Repeated UI blocks (2+) -> extract a child component under `components/<area>/Parent/...`.
- Complex state/effects -> extract to `hooks/<area>/useXxx.ts`.
- Pure helpers -> `utils/<area>/xxx.ts`.
- External/data access -> `services/<area>/xxx.ts`.

## References

- Naming/layout: `.cursor/rules/core/naming-and-layout.mdc`
- Boundaries: `.cursor/rules/core/boundaries.mdc`
- TypeScript: `.cursor/rules/typescript/standards.mdc`
```

## react/security.mdc

```mdc
---
description: React UI security baseline (XSS and untrusted HTML)
globs: "*.tsx,components/**/*.tsx"
alwaysApply: true
---

# React Security

## Untrusted content

- Treat UI-rendered external content as untrusted.
- Avoid `dangerouslySetInnerHTML` unless explicitly required.

## Sanitization

- If rendering untrusted HTML is required, sanitize it first with a reviewed sanitizer.
- If DOMPurify already exists in the repo, prefer it for HTML sanitization.

## Client-side secrets

- Do not embed private secrets, tokens, or internal credentials in client code.
```

## react/state-management.mdc

```mdc
---
description: State management (Zustand) - when to use stores vs props, modal pattern
globs: "*.tsx,stores/**/*.ts"
alwaysApply: false
---

# State Management (Zustand)

Apply when the project uses Zustand (or a similar store) for shared UI state.

## When to Use a Store

- Modal visibility states (settings, dialogs, panels)
- Global UI state
- Shared data across unrelated components
- Cross-component communication without prop drilling

## Avoid Prop Drilling

```tsx
// BAD: Prop drilling
;<Parent onOpenModal={setIsOpen}>
  <Child onOpenModal={onOpenModal} />
</Parent>

// GOOD: Store access
const openModal = useUiStore((state) => state.openModal)
```

## Modal Pattern

Modals should read their visibility state from the store directly, not receive it as props:

```tsx
export function SettingsModal() {
  const isOpen = useUiStore((state) => state.isSettingsModalOpen)
  const closeModal = useUiStore((state) => state.closeSettingsModal)
  // ...
}
```

## Aggregate Hooks

Consider aggregate hooks to reduce store coupling when many components need related state slices.
```

## react/testing.mdc

```mdc
---
description: React testing strategy (opt-in, risk-based)
globs: "*.tsx,*.test.ts,*.test.tsx"
alwaysApply: false
---

# React Testing

## When to test

- Tests are opt-in unless explicitly requested or the change is high-risk.

## Baseline stack

- Unit/component tests: Jest + React Testing Library.
- E2E tests for critical flows: Playwright.

## Test style

- Follow Arrange-Act-Assert.
- Prefer behavior-focused tests over implementation-detail tests.
- Use deterministic setup/teardown; avoid fragile timing assumptions.
```

## react/url-server-state.mdc

```mdc
---
description: URL state and server state strategy (nuqs, RSC-first, TanStack Query optional)
globs: "*.ts,*.tsx,app/**/*.tsx"
alwaysApply: false
---

# URL State and Server State

## Priority order

- Prefer Server Components and server-side fetch/caching first.
- Use client-side server state only when interaction requires it.

## URL search params

- If the repo already uses `nuqs`, prefer `nuqs` for URL param state.
- Avoid ad-hoc parsing spread across components.

## Client server state

- Use TanStack Query only for cases that benefit from client cache/sync behavior.
- Do not introduce query libraries for static or purely server-rendered flows.

## Local vs global

- Prefer local component state and composition first.
- Promote to store/query only when shared behavior or cache lifecycle is truly needed.
```

## refactor.mdc

```mdc
---
description: "Umbrella: Refactor workflow — @refactor, TypeScript refactoring"
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Refactor Rules (umbrella)

Use **@refactor** when refactoring a file or splitting code.

This rule references:

- **Refactor current file**: `.cursor/rules/refactor/file-refactor.mdc` — one symbol per file, no inline types/helpers; run check after
- **TypeScript refactoring**: `.cursor/rules/typescript/refactoring-typescript.mdc` — move types to `types/`, helpers to `utils/`, no index files

## Short summary

- One exported symbol per file; extract types to `types/`, helpers to `utils/`.
- Mandatory: run project check script after refactor.
```

## refactor/file-refactor.mdc

```mdc
---
description: Refactor current file – use @refactor
globs: "*.ts,*.tsx"
alwaysApply: false
---

# Refactor (@refactor)

Use this rule by referencing **@refactor** when you need to refactor the currently selected file.

## What to apply

- All quality criteria and extraction rules come from **code-quality-guidelines**: file size (10–50 target, ~100 max), one export per file, types in `types/<area>/`, no helpers inside components/hooks, constants in dedicated files, when to split, checklist.
- Do not duplicate those rules here; read and apply [code-quality-guidelines.mdc](.cursor/rules/core/code-quality-guidelines.mdc).

## Refactor workflow

1. **Scan** the file: identify responsibilities (UI, state/effects, pure helpers, types, large constants).
2. **Decide** what to extract using the heuristics and extraction decision tree in code-quality-guidelines (e.g. multiple functions → one per file; inline types → `types/<area>/`; complex logic → hook or util; repeated JSX → child components; large collections → constant files).
3. **Extract** and create/update files; fix all imports; remove unused code.
4. **Run** the project check script (e.g. `pnpm run check`, `npm run check`) and fix until clean.

## Mandatory after refactor

- Run the project's check script.
- Ensure the result satisfies the checklist in code-quality-guidelines.
```

## rust.mdc

```mdc
---
description: "Umbrella: Rust + Tauri (layout, SQL/prompt separation, commands checklist)"
globs: "*.rs,*.sql,*.prompt,src-tauri/**/*"
alwaysApply: false
---

# Rust / Tauri Rules (umbrella)

Use **@rust** when working on Rust or Tauri code.

This rule references:

- **Rust + Tauri**: `.cursor/rules/rust/rust-tauri.mdc` — one-thing-per-file, module layout, SQL/prompt in separate files, Tauri command checklist (command file + lib.rs + permissions)
- **Cross-platform**: `.cursor/rules/rust/crossplatform.mdc` — correct `#[cfg]` usage, platform imports, target-specific deps
- **Pest grammars**: `.cursor/rules/rust/pest.mdc` — `.pest` authoring/debugging and atomic/silent rule guidance
- **RON usage**: `.cursor/rules/rust/ron.mdc` — readable `.ron` and serde-based (de)serialization
- **Lint triage**: `.cursor/rules/rust/linthunter.mdc` — classify clippy/compiler lint issues and false positives

## Short summary

- One public function/type/trait per file; no inline SQL or prompts (use `include_str!()`).
- New Tauri command: (1) command file, (2) register in `lib.rs`, (3) add to `commands.allow` in permissions.
- Use `#[cfg]` (not `cfg!`) for platform-specific APIs and imports.
```

## rust/crossplatform.mdc

```mdc
---
description: Cross-platform Rust conditional compilation
globs: "*.rs,Cargo.toml"
alwaysApply: false
---

# Cross-platform Rust

## Goal

Compile cleanly on supported targets (Windows/Linux/macOS) without cfg-related warnings/errors.

## Rules

- Use `#[cfg(...)]` for platform-specific code paths. Do not use `cfg!()` with platform-specific APIs.
- Scope platform-specific imports inside the matching `#[cfg]` block or module.
- Prefer target families (`unix`, `windows`) when behavior is family-wide.
- Use `any()`, `all()`, `not()` predicates for readable conditions.
- Keep platform implementations in separate modules with a unified public interface.
- Keep Cargo target dependencies under `[target.'cfg(...)'.dependencies]`.

## Common pitfalls

- `cfg!()` still type-checks all branches; this breaks with `std::os::windows::*` imports on Unix.
- Hiding conditional compilation issues with `#[allow(unused_imports)]`.
- Over-specific predicates when a family predicate is enough.

## Validation

- Check cfg values with `rustc --print=cfg` (or a specific `--target`).
- Run formatting/lints/tests on relevant targets in CI when possible.
```

## rust/linthunter.mdc

```mdc
---
description: Rust lint triage and false-positive analysis
globs: "*.rs"
alwaysApply: false
---

# Rust Lint Triage

## Goal

Decide whether a lint is valid, likely false-positive, or uncertain.

## Workflow

1. Capture lint name, location, message, and local snippet.
2. Trace related moves/borrows/clones across nearby scopes.
3. Check missing imports/traits and macro expansion context.
4. Classify: valid, likely false-positive, or uncertain.
5. Recommend action:
   - refactor to satisfy lint
   - local `#[allow(...)]` with justification
   - global allow only with strong project-level reason

## Notes

- Prefer fixing root causes over suppressing lints.
- Keep suppressions narrow and documented.
```

## rust/pest.mdc

```mdc
---
description: Pest grammar authoring and debugging
globs: "*.pest,*.rs"
alwaysApply: false
---

# Pest Grammar Guidance

## Scope

Use when editing `.pest` grammars or Rust parser code based on Pest.

## Rules

- Keep grammar changes small and focused; prefer minimal diffs.
- When debugging parse issues, point to the exact rule and propose 1-3 fixes.
- Use silent rules (`_ {}`) to reduce noisy parse trees when needed.
- Use atomic (`@{}`) or compound-atomic (`${}`) rules for ambiguity/perf hotspots.
- Keep rule ordering intentional (most-specific first).
- Add minimal parser tests (`parses_to!` or small `Parser::parse()` assertions).

## Pitfalls

- Missing `WHITESPACE`/`COMMENT` silent rules when grammar expects spacing/comments.
- Left-recursive or ambiguous patterns causing heavy backtracking.
```

## rust/ron.mdc

```mdc
---
description: RON (Rusty Object Notation) usage
globs: "*.ron,*.rs"
alwaysApply: false
---

# RON Guidance

## Scope

Use when editing `.ron` files or Rust code that serializes/deserializes RON.

## Rules

- Keep `.ron` human-readable (trailing commas, concise comments where helpful).
- Prefer raw strings (`r#"..."#`) in Rust for multiline or escaped RON payloads.
- Prefer `serde` derives for domain types.
- Surface parse/serialize errors with context; avoid silent fallbacks.

## Typical APIs

- Deserialize: `ron::de::from_str::<T>(...)`
- Serialize: `ron::ser::to_string(...)`
```

## rust/rust-tauri.mdc

```mdc
---
description: Rust + Tauri standards (strict one-thing-per-file)
globs: "*.rs,*.sql,*.prompt,*.txt"
alwaysApply: true
---

# Rust + Tauri Standards (strict)

## Goal

Optimize for long-term maintainability with **many small, focused files** and explicit boundaries.

## Language & Style

- English-only code, comments, and identifiers.
- Prefer `struct`/`enum` definitions in dedicated files.
- Use explicit error types or result enums for expected failures.

## Async & Concurrency (when applicable)

- Prefer a single async runtime per app. If the project uses **Tokio**, follow the practices below.
- Use `async fn` and `.await` with clear cancellation paths; avoid detached tasks without an owner.
- Do not block inside async tasks; offload blocking work to a blocking pool.
- Use `tokio::select!` (or equivalent) to compose cancellation, timeouts, and concurrent work.
- Prefer **bounded channels** for backpressure; choose the channel type by intent (mpsc/oneshot/broadcast/watch).
- Avoid holding locks across `.await`; use async-aware primitives for shared state.

## One Thing Per File (STRICT)

- **Exactly one exported symbol per file** for your own Rust modules:
  - One public function **or** one public type **or** one public trait per file.
- No helpers inside the same file. Extract helpers to `utils/`-style modules.
- Files should do one thing: data model, boundary call, or pure logic.
- **Single-purpose functions only**: if a function mixes multiple tasks, split into smaller functions and keep a thin orchestrator.

## Module Manifests (Exception)

- `mod.rs` files may declare multiple `mod` entries.
- No logic, constants, or functions inside `mod.rs`.

## Module Layout (STRICT)

- `src-tauri/src/` is for Rust code only.
- `src-tauri/src/services/`: external boundaries (IO, DB, network).
- `src-tauri/src/utils/`: pure logic (no IO).
- `src-tauri/src/models/`: domain types (one type per file).
- No "misc" modules like `helpers.rs` or `common.rs`.

## SQL Separation (STRICT)

- **No inline SQL strings** inside `.rs` files.
- Put each query in its own file under `src-tauri/sql/<area>/Xxx.sql`.
- Load with `include_str!()` in Rust code.

## Prompt Separation (STRICT)

- **No inline LLM or AI prompts** inside `.rs` files.
- Put each prompt in its own file under `src-tauri/prompts/<area>/Xxx.prompt`.
- Load with `include_str!()` in Rust code.

## Boundaries

- Route handlers or command handlers should be thin:
  - Validate input
  - Call a single service function
  - Return explicit results

## Tauri Commands Checklist (MANDATORY)

When creating a new Tauri command, **all three steps are required**:

1. Create the command file: `src-tauri/src/commands/<command_name>.rs`
2. Register in invoke handler: add to `tauri::generate_handler![]` in `src-tauri/src/lib.rs`
3. **Add to permissions**: add command name to `commands.allow` in `src-tauri/permissions/<app-name>-default.toml`

**CRITICAL**: Without step 3, the command will fail at runtime with "not allowed. Command not found" error.

## Module Conflict (STRICT)

Rust allows **only one** definition per module name. You cannot have both:

- `foo.rs` (single file that defines the module)
- `foo/mod.rs` (directory that defines the module)

If both exist, the compiler fails with: `failed to resolve mod 'foo': file for module found at both "…/foo.rs" and "…/foo/mod.rs"`.

**Resolution:**

1. **Keep the directory** (`foo/` with `mod.rs` and submodules); **delete** the standalone `foo.rs`.
2. If the deleted `foo.rs` contained **impl blocks** (methods on a type) that call sites use, add a thin **delegation impl** inside the directory:
   - Create `foo/impl_session.rs` (or a name that matches the type, e.g. `impl_session` for `ImapSession`).
   - In it, `impl Type { pub async fn method(&mut self, …) { free_function(self, …).await } }` for each method that was in the old `foo.rs`.
   - In `foo/mod.rs`, add `mod impl_session;` (no `pub use` needed).
3. If the deleted file only re-exported or duplicated logic that already lives in the directory’s submodules, no extra impl file is needed; ensure the directory’s `mod.rs` re-exports what the rest of the crate needs.

## Testing (async)

- Use `#[tokio::test]` for async unit tests.
- Use `tokio::time::pause()` for time-dependent tests to avoid real delays.

## Dead Code

- Remove unused functions and methods, or they will trigger `dead_code` / `unused` warnings.
- For enums where all variants share the same suffix (e.g. `*Error`), Clippy may suggest `enum_variant_names`. You can either rename variants or add `#[allow(clippy::enum_variant_names)]` on the enum if the naming is intentional.

## Clippy

- Prefer **`map.contains_key("key")`** over **`map.get("key").is_some()`**.
- For stripping a prefix and then searching, use **`s.strip_prefix('x')`** and work on the returned slice instead of **`s[1..].find(...)`** (satisfies `manual_strip`).

## Validation

After meaningful changes, run the project's check script (e.g. `pnpm run check`, `npm run check`).
```

## styling/bootstrap.mdc

```mdc
---
description: Bootstrap standards (grid, components, utilities, accessibility)
globs: "*.html,*.php,*.blade.php,*.tsx,*.jsx,*.vue"
alwaysApply: false
---

# Bootstrap Standards

## Layout and components

- Use Bootstrap grid (`container`, `row`, `col-*`) for responsive structure.
- Prefer Bootstrap components/utilities over large custom CSS overrides.
- Keep custom CSS minimal and focused on app-specific branding.
- Use semantic HTML and appropriate ARIA attributes for component accessibility.

## Forms and feedback

- Use Bootstrap validation classes for clear, immediate form feedback.
- Surface actionable errors with consistent alert/inline patterns.
- Ensure labels, help text, and error text are programmatically associated.

## Theming and customization

- Prefer Sass variables/mixins for theming instead of ad-hoc overrides.
- Keep style tokens centralized and consistent across components.

## Performance

- Include only required Bootstrap bundles/components when possible.
- Optimize assets (images/fonts/scripts) and avoid redundant UI libraries.
```

## styling/tailwind/baseline.mdc

```mdc
---
description: Tailwind v4 baseline defaults (utility-first, setup, no apply in production)
globs: "*.ts,*.tsx,*.css,*.hbs,*.liquid"
alwaysApply: true
---

# Tailwind Baseline

- Utility-first by default.
- Do not use `@apply` in production code (only short-lived spikes).
- Keep Tailwind as a build-time concern.
- Import Tailwind from one global stylesheet:
  - `@import 'tailwindcss';`
- Keep global stylesheet imports centralized in app/root entries.
```

## styling/tailwind/class-authoring.mdc

```mdc
---
description: Tailwind class authoring conventions (ordering, variants, readability)
globs: "*.ts,*.tsx,*.hbs,*.liquid"
alwaysApply: true
---

# Tailwind Class Authoring

- Keep class lists readable and stable.
- Use this order when possible:
  - layout/display -> positioning -> sizing -> spacing -> typography -> colors -> border/radius -> effects -> motion -> state.
- If a component repeatedly needs 20+ utilities:
  - extract a wrapper component or variant map.
- Prefer `cn()` + variant maps (CVA if already present) over inline conditional class spaghetti.
- Avoid creating custom CSS utility layers that duplicate Tailwind.
```

## styling/tailwind/performance-hygiene.mdc

```mdc
---
description: Tailwind performance and output hygiene
globs: "*.ts,*.tsx,*.css,*.hbs,*.liquid"
alwaysApply: true
---

# Tailwind Performance and Hygiene

- Keep markup clean; avoid unnecessary utility churn.
- Avoid heavy arbitrary values unless justified by design tokens.
- Remove unused style systems/component libraries when possible.
- For content-heavy pages, prioritize critical CSS path and lazy-load non-critical media/scripts.
```

## styling/tailwind/responsive.mdc

```mdc
---
description: Tailwind responsive strategy (mobile-first and breakpoint discipline)
globs: "*.ts,*.tsx,*.hbs,*.liquid"
alwaysApply: true
---

# Tailwind Responsive Strategy

- Mobile-first defaults, then progressive breakpoints:
  - `sm` -> `md` -> `lg` -> `xl` -> `2xl`
- Avoid breakpoint thrash on the same property unless justified.
- Prefer fluid primitives (`w-full`, `max-w-*`, `mx-auto`) before micro-managing every breakpoint.
```

## styling/tailwind/stack-notes.mdc

```mdc
---
description: Tailwind stack-specific notes (React/Next, Blade/Livewire, Ghost/Alpine)
globs: "*.tsx,*.blade.php,*.hbs,*.liquid"
alwaysApply: false
---

# Tailwind Stack Notes

## React / Next

- Prefer utility composition in components and variant maps for reusable primitives.
- Use state variants (`aria-*`, `data-*`) for UI libraries that expose state attributes.

## Blade / Livewire

- Keep Tailwind in Blade/Livewire components; avoid inline style attributes.
- Prefer token utilities over ad-hoc colors.

## Ghost / Handlebars / Alpine

- Use utilities directly in templates and partial composition for reuse.
- Keep Alpine state small; avoid complex JS when semantic HTML can solve the interaction.
```

## styling/tailwind/state-accessibility.mdc

```mdc
---
description: Tailwind state and accessibility styling (focus-visible, disabled, aria/data variants)
globs: "*.ts,*.tsx,*.hbs,*.liquid"
alwaysApply: true
---

# Tailwind State and Accessibility

- Interactive components must have visible `focus-visible` styles.
- Prefer ring-based focus over removing outlines.
- Disabled states should be explicit:
  - `disabled:opacity-50 disabled:pointer-events-none`
- Prefer `aria-*` and `data-*` variants for state-driven styling (especially Radix/Shadcn patterns).
- Do not hide information needed by assistive technology.
```

## styling/tailwind/tokens-theming.mdc

```mdc
---
description: Tailwind tokens and theming strategy (semantic tokens + CSS variables)
globs: "*.ts,*.tsx,*.css"
alwaysApply: true
---

# Tailwind Tokens and Theming

- Prefer semantic tokens over hardcoded color utilities:
  - `bg-background`, `text-foreground`, `border-border`, `ring-ring`
- Prefer CSS variables as theme source of truth.
- Extend Tailwind config only with owned tokens.
- Avoid ad-hoc custom scales and random literal colors.
- For dark mode, prefer class-based switching (`.dark`) and token changes, not per-component hardcoded dark palettes.
```

## styling/tailwindcss.mdc

```mdc
---
description: Legacy Tailwind entrypoint (use @tailwind umbrella)
globs: "*.ts,*.tsx,*.css"
alwaysApply: false
---

# Tailwind Legacy Pointer

Use **@tailwind** and the split Tailwind rules:

- `.cursor/rules/tailwind.mdc`
- `.cursor/rules/styling/tailwind/baseline.mdc`
- `.cursor/rules/styling/tailwind/tokens-theming.mdc`
- `.cursor/rules/styling/tailwind/class-authoring.mdc`
- `.cursor/rules/styling/tailwind/state-accessibility.mdc`
- `.cursor/rules/styling/tailwind/responsive.mdc`
- `.cursor/rules/styling/tailwind/performance-hygiene.mdc`
- `.cursor/rules/styling/tailwind/stack-notes.mdc`
```

## tailwind.mdc

```mdc
---
description: "Umbrella: Tailwind CSS v4 standards (tokens, authoring, states, responsive, hygiene)"
globs: "*.ts,*.tsx,*.css,*.hbs,*.liquid"
alwaysApply: false
---

# Tailwind Rules (umbrella)

Use **@tailwind** when working on Tailwind styles, component variants, or theme tokens.

This rule references:

- **Baseline**: `.cursor/rules/styling/tailwind/baseline.mdc`
- **Tokens/theming**: `.cursor/rules/styling/tailwind/tokens-theming.mdc`
- **Class authoring**: `.cursor/rules/styling/tailwind/class-authoring.mdc`
- **State/a11y**: `.cursor/rules/styling/tailwind/state-accessibility.mdc`
- **Responsive**: `.cursor/rules/styling/tailwind/responsive.mdc`
- **Performance/hygiene**: `.cursor/rules/styling/tailwind/performance-hygiene.mdc`
- **Stack specifics**: `.cursor/rules/styling/tailwind/stack-notes.mdc`

## Short summary

- Utility-first, token-driven, accessible Tailwind v4.
- Predictable class authoring and responsive behavior.
- Variant-based reuse without creating a parallel CSS system.
```

## typescript.mdc

```mdc
---
description: "Umbrella: TypeScript standards, type conventions, and refactor checks"
globs: "*.ts,*.tsx,types/**/*.ts"
alwaysApply: false
---

# TypeScript Rules (umbrella)

Use **@typescript** when writing or refactoring TypeScript.

This rule references:

- **Standards**: `.cursor/rules/typescript/standards.mdc` - strict TS style, one export per file, Next.js exceptions
- **Types conventions**: `.cursor/rules/typescript/types-conventions.mdc` - naming patterns and result shapes
- **Refactoring flow**: `.cursor/rules/typescript/refactoring-typescript.mdc` - single source of truth for extraction/splitting
- **Post-change checks**: `.cursor/rules/typescript/typescript-debug.mdc` - check order and failure handling

## Short summary

- Strict TypeScript, no `any`, explicit public API types.
- Keep types under `types/<area>/` with one type per file.
- Split large mixed-responsibility files early.
```

## typescript/refactoring-typescript.mdc

```mdc
---
description: When creating or refactoring – follow code quality guidelines
globs: "*.ts,*.tsx"
alwaysApply: true
---

# Refactoring TypeScript/React Code (strict)

When **creating** new code or **refactoring** existing code, follow the single source of truth:

- **[code-quality-guidelines.mdc](.cursor/rules/core/code-quality-guidelines.mdc)** – file size (10–50 target, ~100 max), one export per file, types in `types/`, no helpers inside components/hooks, no index files, constants in dedicated files, when to split, decision rules, checklist, common issues.

For a **one-shot refactor** of the current file, use **@refactor** (see [file-refactor.mdc](.cursor/rules/refactor/file-refactor.mdc)).
```

## typescript/standards.mdc

```mdc
---
description: TypeScript + React standards (strict one-thing-per-file)
globs: "*.ts,*.tsx"
alwaysApply: true
---

# TypeScript + React Standards (strict)

## Goal

Optimize the codebase for agent context and long-term maintainability by enforcing **many small, focused files**.

## Language & Style

- Use `interface` for exported object contracts/props.
- Use `type` for unions and utility/mapped/conditional types.
- Prefer const objects or union types over enums.
- Prefer `function` keyword for exported functions; use arrow functions for short local callbacks.
- Import React members selectively (e.g. `import { useEffect } from 'react'`) rather than `import * as React`.
- Use `import type` for type-only imports.
- `const` by default; `let` only when necessary.
- Avoid `any`; prefer `unknown` at boundaries and narrow with type guards.
- English-only code, comments, and identifiers.
- Sort props alphabetically when feasible for consistency.
- Add brief comments for non-obvious variables; use JSDoc for exported functions (parameters and return type) when it improves discoverability.
- Use explicit return types for exported functions and public APIs.
- Prefer immutable data (`readonly`, `as const`) when values should not change.

## One Thing Per File (STRICT)

- **Exactly one exported symbol per file** for your own modules:
  - `.tsx`: one exported React component.
  - `.ts` (utils/services): one exported function.
  - `.ts` (types): one exported `interface` or `type`.
- **Single-purpose functions only**: if a function performs multiple tasks, split it and keep a thin orchestrator.

## Next.js Special-file Exceptions

Some Next.js files require additional exports by convention. Allowed exceptions:

- `app/**/layout.tsx`, `app/**/page.tsx`: `default export` + `metadata` / `generateMetadata` / `viewport` (etc.).
- `app/api/**/route.ts`: multiple HTTP method exports and route config exports.

## Types (STRICT)

- **No inline `interface`/`type` declarations** in components, hooks, utils, services, or route handlers.
- Put types in `types/<area>/...` as dedicated files.
- One type per file.

## Type Naming Patterns (recommended)

Use explicit names that communicate role:

- `XxxParams` / `XxxInput` for function inputs
- `XxxResult` for service results
- `XxxError` for domain error shapes
- `UseXxxParams` / `UseXxxReturn` for hook contracts
- `XxxProps` for component props
- For non-trivial function contracts, prefer RORO (`XxxInput` -> `XxxResult`).

## Result Shape for Expected Failures (recommended)

For boundaries that can fail (services), prefer a typed result object instead of throwing:

- `type XxxResult = { ok: true; value: T } | { ok: false; error: XxxError }`

## Helpers (STRICT)

- Do not keep helper functions inside components/hooks.
- If a helper is needed, extract it to `utils/<area>/SomeHelper.ts` (one function per file).

## Next.js TS Hygiene (docs-aligned)

- Do not edit `next-env.d.ts` (it is generated).
- If you need custom `.d.ts`, create a new file and include it in `tsconfig.json`.

## Validation

Run the project's check script after meaningful changes (e.g. `pnpm run check`, `npm run check`).
```

## typescript/types-conventions.mdc

```mdc
---
description: Types conventions (agent-optimized, one type per file)
globs: "types/**/*.ts"
alwaysApply: true
---

# Types Conventions

## One Type Per File (STRICT)

- Each file under `types/` exports **exactly one** `interface` (preferred for
  extendable object contracts) or `type` (unions and utility/mapped/conditional
  types).
- File name must match the exported symbol.

## Naming Patterns

Prefer explicit names that communicate role:

- `XxxParams` / `XxxInput` for function inputs
- `XxxResult` for service results (success/error)
- `XxxError` for domain error shapes
- `UseXxxParams` / `UseXxxReturn` for hook contracts
- `XxxProps` for component props

## Result Shape (recommended)

For boundaries that can fail (services), prefer a typed result object instead of throwing for expected failures:

- `type XxxResult = { ok: true; value: T } | { ok: false; error: XxxError }`

## Where Types Are Allowed

- Types must live in `types/<area>/...`.
- Do not declare inline types/interfaces in components/hooks/utils/services/route handlers.
```

## typescript/typescript-debug.mdc

```mdc
---
description: Post creating and refactoring checks (run after every meaningful change)
globs: "*.ts,*.tsx"
alwaysApply: true
---

# Post Creating and Refactoring Checks

## Golden path

Run this after every meaningful change:

- The project's check script (e.g. `pnpm run check`, `npm run check`).
- If the project has separate steps: run type-check first, then format (format can fix some lint issues), then lint.

## If something fails

- Type errors: fix types first (do not format/lint until types are clean).
- Lint errors: prefer refactoring into smaller files instead of adding ignores.
- Formatting churn: keep diffs small; avoid unrelated reformatting.

## Frontend / Vite

- In frontend bundles, **never reference Node globals** (e.g. `process`) at runtime; they can ship to the bundle and cause "process is not defined" in browsers or mobile webviews. Prefer `import.meta.env` (Vite) or equivalent for env vars.

## Checklist and common issues

- For the full checklist (file size, one per file, types in `types/`, etc.) and common issues/fixes, see [code-quality-guidelines.mdc](.cursor/rules/core/code-quality-guidelines.mdc).
```

## vite/runtime-safety.mdc

```mdc
---
description: Vite runtime safety — no Node globals in browser bundles
globs: "*.ts,*.tsx,*.js,*.jsx,vite.config.*"
alwaysApply: false
---

# Vite Runtime Safety

## Goal

Prevent runtime crashes when the app or widget runs in the browser (e.g. Staffbase or other hosts). Node globals (`process`, `global`, `Buffer`) are often **not defined** in the browser.

## Rules

- **No Node globals at runtime**: Do not reference `process`, `global`, or `Buffer` in code that ships to the browser. Libraries may still pull them in.
- **If you see** `Uncaught ReferenceError: process is not defined`: add a minimal shim early in the bundle (before other imports), e.g. a small `ensureProcessShim` (or equivalent) imported from entry and dev entry.
- **Environment variables**: Prefer compile-time replacements via Vite `define` (e.g. `import.meta.env.VITE_*`) for app configuration. Avoid dynamic env access patterns that the bundler cannot statically replace.

## Verification

- Run type-check and build (`yarn type-check`, `yarn build` or project equivalent).
- Load the built output in the real host and check the browser console for runtime errors.
```
